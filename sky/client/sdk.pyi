"""Stub for sky.client.sdk, generated by stubgen."""
import io
from typing import Any, Dict, List, Optional, Tuple, Union

from _typeshed import Incomplete
import requests

import sky
from sky import admin_policy as admin_policy
from sky import backends as backends
from sky import exceptions as exceptions
from sky import sky_logging as sky_logging
from sky import skypilot_config as skypilot_config
from sky.server import common as server_common
from sky.server import rest as rest
from sky.server.requests import payloads as payloads
from sky.skylet import autostop_lib as autostop_lib
from sky.skylet import constants as constants
from sky.usage import usage_lib as usage_lib
from sky.utils import admin_policy_utils as admin_policy_utils
from sky.utils import annotations as annotations
from sky.utils import cluster_utils as cluster_utils
from sky.utils import common as common
from sky.utils import common_utils as common_utils
from sky.utils import dag_utils as dag_utils
from sky.utils import env_options as env_options
from sky.utils import infra_utils as infra_utils
from sky.utils import rich_utils as rich_utils
from sky.utils import status_lib as status_lib
from sky.utils import subprocess_utils as subprocess_utils
from sky.utils import ux_utils as ux_utils
from sky.utils.kubernetes import ssh_utils as ssh_utils

logger: Incomplete


def reload_config() -> None:
    ...


def stream_response(request_id: Optional[str],
                    response: requests.Response,
                    output_stream: Optional['io.TextIOBase'] = ...,
                    resumable: bool = ...) -> Any:
    ...


def check(infra_list: Optional[Tuple[str, ...]],
          verbose: bool,
          workspace: Optional[str] = ...) -> server_common.RequestId:
    ...


def enabled_clouds(workspace: Optional[str] = ...,
                   expand: bool = ...) -> server_common.RequestId:
    ...


def list_accelerators(gpus_only: bool = ...,
                      name_filter: Optional[str] = ...,
                      region_filter: Optional[str] = ...,
                      quantity_filter: Optional[int] = ...,
                      clouds: Optional[Union[List[str], str]] = ...,
                      all_regions: bool = ...,
                      require_price: bool = ...,
                      case_sensitive: bool = ...) -> server_common.RequestId:
    ...


def list_accelerator_counts(
        gpus_only: bool = ...,
        name_filter: Optional[str] = ...,
        region_filter: Optional[str] = ...,
        quantity_filter: Optional[int] = ...,
        clouds: Optional[Union[List[str],
                               str]] = ...) -> server_common.RequestId:
    ...


def optimize(
    dag: sky.Dag,
    minimize: common.OptimizeTarget = ...,
    admin_policy_request_options: Optional[admin_policy.RequestOptions] = ...
) -> server_common.RequestId:
    ...


def workspaces() -> server_common.RequestId:
    ...


def validate(
    dag: sky.Dag,
    workdir_only: bool = ...,
    admin_policy_request_options: Optional[admin_policy.RequestOptions] = ...
) -> None:
    ...


def dashboard(starting_page: Optional[str] = ...) -> None:
    ...


def launch(task: Union['sky.Task', 'sky.Dag'],
           cluster_name: Optional[str] = ...,
           retry_until_up: bool = ...,
           idle_minutes_to_autostop: Optional[int] = ...,
           wait_for: Optional[autostop_lib.AutostopWaitFor] = ...,
           dryrun: bool = ...,
           down: bool = ...,
           backend: Optional['backends.Backend'] = ...,
           optimize_target: common.OptimizeTarget = ...,
           no_setup: bool = ...,
           clone_disk_from: Optional[str] = ...,
           fast: bool = ...,
           _need_confirmation: bool = ...,
           _is_launched_by_jobs_controller: bool = ...,
           _is_launched_by_sky_serve_controller: bool = ...,
           _disable_controller_check: bool = ...) -> server_common.RequestId:
    ...


def exec(
        task: Union['sky.Task', 'sky.Dag'],
        cluster_name: Optional[str] = ...,
        dryrun: bool = ...,
        down: bool = ...,
        backend: Optional['backends.Backend'] = ...) -> server_common.RequestId:
    ...


def tail_logs(cluster_name: str,
              job_id: Optional[int],
              follow: bool,
              tail: int = ...,
              output_stream: Optional['io.TextIOBase'] = ...) -> int:
    ...


def download_logs(cluster_name: str,
                  job_ids: Optional[List[str]]) -> Dict[str, str]:
    ...


def start(cluster_name: str,
          idle_minutes_to_autostop: Optional[int] = ...,
          wait_for: Optional[autostop_lib.AutostopWaitFor] = ...,
          retry_until_up: bool = ...,
          down: bool = ...,
          force: bool = ...) -> server_common.RequestId:
    ...


def down(cluster_name: str, purge: bool = ...) -> server_common.RequestId:
    ...


def stop(cluster_name: str, purge: bool = ...) -> server_common.RequestId:
    ...


def autostop(cluster_name: str,
             idle_minutes: int,
             wait_for: Optional[autostop_lib.AutostopWaitFor] = ...,
             down: bool = ...) -> server_common.RequestId:
    ...


def queue(cluster_name: str,
          skip_finished: bool = ...,
          all_users: bool = ...) -> server_common.RequestId:
    ...


def job_status(cluster_name: str,
               job_ids: Optional[List[int]] = ...) -> server_common.RequestId:
    ...


def cancel(
        cluster_name: str,
        all: bool = ...,
        all_users: bool = ...,
        job_ids: Optional[List[int]] = ...,
        _try_cancel_if_cluster_is_init: bool = ...) -> server_common.RequestId:
    ...


def status(cluster_names: Optional[List[str]] = ...,
           refresh: common.StatusRefreshMode = ...,
           all_users: bool = ...) -> server_common.RequestId:
    ...


def endpoints(cluster: str,
              port: Optional[Union[int, str]] = ...) -> server_common.RequestId:
    ...


def cost_report(days: Optional[int] = ...) -> server_common.RequestId:
    ...


def storage_ls() -> server_common.RequestId:
    ...


def storage_delete(name: str) -> server_common.RequestId:
    ...


def local_up(gpus: bool,
             ips: Optional[List[str]],
             ssh_user: Optional[str],
             ssh_key: Optional[str],
             cleanup: bool,
             context_name: Optional[str] = ...,
             password: Optional[str] = ...) -> server_common.RequestId:
    ...


def local_down() -> server_common.RequestId:
    ...


def ssh_up(infra: Optional[str] = ...,
           file: Optional[str] = ...) -> server_common.RequestId:
    ...


def ssh_down(infra: Optional[str] = ...) -> server_common.RequestId:
    ...


def realtime_kubernetes_gpu_availability(
        context: Optional[str] = ...,
        name_filter: Optional[str] = ...,
        quantity_filter: Optional[int] = ...,
        is_ssh: Optional[bool] = ...) -> server_common.RequestId:
    ...


def kubernetes_node_info(
        context: Optional[str] = ...) -> server_common.RequestId:
    ...


def status_kubernetes() -> server_common.RequestId:
    ...


def get(request_id: str) -> Any:
    ...


def stream_and_get(request_id: Optional[str] = ...,
                   log_path: Optional[str] = ...,
                   tail: Optional[int] = ...,
                   follow: bool = ...,
                   output_stream: Optional['io.TextIOBase'] = ...) -> Any:
    ...


def api_cancel(request_ids: Optional[Union[str, List[str]]] = ...,
               all_users: bool = ...,
               silent: bool = ...) -> server_common.RequestId:
    ...


def api_status(request_ids: Optional[List[str]] = ...,
               all_status: bool = ...) -> List[payloads.RequestPayload]:
    ...


def api_info() -> Dict[str, Any]:
    ...


def api_start(*,
              deploy: bool = ...,
              host: str = ...,
              foreground: bool = ...,
              metrics: bool = ...,
              metrics_port: Optional[int] = ...,
              enable_basic_auth: bool = ...) -> None:
    ...


def api_stop() -> None:
    ...


def api_server_logs(follow: bool = ..., tail: Optional[int] = ...) -> None:
    ...


def api_login(endpoint: Optional[str] = ...,
              relogin: bool = ...,
              service_account_token: Optional[str] = ...) -> None:
    ...
