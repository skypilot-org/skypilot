/**
 * This code was generated by v0 by Vercel.
 * @see https://v0.dev/t/t5SMh01qKCm
 * Documentation: https://v0.dev/docs#integrating-generated-code-into-your-nextjs-app
 */
'use client';

import React, {
  useState,
  useEffect,
  useMemo,
  useCallback,
  useRef,
} from 'react';
import { useRouter } from 'next/router';
import { CircularProgress } from '@mui/material';
import {
  CustomTooltip as Tooltip,
  NonCapitalizedTooltip,
  REFRESH_INTERVAL,
  TimestampWithTooltip,
} from '@/components/utils';
import Link from 'next/link';
import { Button } from '@/components/ui/button';
import { Card } from '@/components/ui/card';
import {
  Table,
  TableHeader,
  TableRow,
  TableHead,
  TableBody,
  TableCell,
} from '@/components/ui/table';
import { getClusters, getClusterHistory } from '@/data/connectors/clusters';
import { getWorkspaces } from '@/data/connectors/workspaces';
import { getUsers } from '@/data/connectors/users';
import { sortData } from '@/data/utils';
import { SquareCode, Terminal, RotateCwIcon } from 'lucide-react';
import { relativeTime } from '@/components/utils';
import { Layout } from '@/components/elements/layout';
import {
  SSHInstructionsModal,
  VSCodeInstructionsModal,
} from '@/components/elements/modals';
import { StatusBadge } from '@/components/elements/StatusBadge';
import { useMobile } from '@/hooks/useMobile';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import dashboardCache from '@/lib/cache';
import cachePreloader from '@/lib/cache-preloader';
import { ChevronDownIcon, ChevronRightIcon } from 'lucide-react';
import yaml from 'js-yaml';
import { UserDisplay } from '@/components/elements/UserDisplay';

// Helper function to format cost (copied from workspaces.jsx)
// const formatCost = (cost) => { // Cost function removed
//   if (cost >= 10) {
//     // Use the user-updated threshold of 10
//     return cost.toFixed(1);
//   }
//   return cost.toFixed(2);
// };

const ALL_WORKSPACES_VALUE = '__ALL_WORKSPACES__'; // Define constant for "All Workspaces"

// Define constant for "All Users" similar to workspaces
const ALL_USERS_VALUE = '__ALL_USERS__';

// Define filter options for the filter dropdown
const PROPERTY_OPTIONS = [
  {
    label: 'Status',
    value: 'status',
  },
  {
    label: 'Cluster',
    value: 'cluster',
  },
  {
    label: 'User',
    value: 'user',
  },
  {
    label: 'Infra',
    value: 'infra',
  },
  {
    label: 'Workspace',
    value: 'workspace',
  },
];

const OPERATORS_OPTIONS = [
  {
    label: '=',
    value: 'Equals',
  },
  {
    label: '!=',
    value: 'Does not equal',
  },
  {
    label: ':',
    value: 'Contains',
  },
  {
    label: '!:',
    value: 'Does not contain',
  },
];

// Helper function to filter clusters by name
export function filterClustersByName(clusters, nameFilter) {
  // If no name filter, return all clusters
  if (!nameFilter || nameFilter.trim() === '') {
    return clusters;
  }

  // Filter clusters by the name filter (case-insensitive partial match)
  const filterLower = nameFilter.toLowerCase().trim();
  return clusters.filter((cluster) => {
    const clusterName = cluster.cluster || '';
    return clusterName.toLowerCase().includes(filterLower);
  });
}

// Helper function to format autostop information, similar to _get_autostop in CLI utils
const formatAutostop = (autostop, toDown) => {
  let autostopStr = '';
  let separation = '';

  if (autostop >= 0) {
    autostopStr = autostop + 'm';
    separation = ' ';
  }

  if (toDown) {
    autostopStr += `${separation}(down)`;
  }

  if (autostopStr === '') {
    autostopStr = '-';
  }

  return autostopStr;
};

// Helper function to format username for display (reuse from users.jsx)
const formatUserDisplay = (username, userId) => {
  if (username && username.includes('@')) {
    const emailPrefix = username.split('@')[0];
    // Show email prefix with userId if they're different
    if (userId && userId !== emailPrefix) {
      return `${emailPrefix} (${userId})`;
    }
    return emailPrefix;
  }
  // If no email, show username with userId in parentheses only if they're different
  const usernameBase = username || userId || 'N/A';

  // Skip showing userId if it's the same as username
  if (userId && userId !== usernameBase) {
    return `${usernameBase} (${userId})`;
  }

  return usernameBase;
};

// Helper function to format duration in a human-readable way
const formatDuration = (durationSeconds) => {
  if (!durationSeconds || durationSeconds === 0) {
    return '-';
  }

  // Convert to a whole number if it's a float
  durationSeconds = Math.floor(durationSeconds);

  const units = [
    { value: 31536000, label: 'y' }, // years (365 days)
    { value: 2592000, label: 'mo' }, // months (30 days)
    { value: 86400, label: 'd' }, // days
    { value: 3600, label: 'h' }, // hours
    { value: 60, label: 'm' }, // minutes
    { value: 1, label: 's' }, // seconds
  ];

  let remaining = durationSeconds;
  let result = '';
  let count = 0;

  for (const unit of units) {
    if (remaining >= unit.value && count < 2) {
      const value = Math.floor(remaining / unit.value);
      result += `${value}${unit.label} `;
      remaining %= unit.value;
      count++;
    }
  }

  return result.trim() || '0s';
};

export function Clusters() {
  const router = useRouter();
  const [loading, setLoading] = useState(false);
  const refreshDataRef = React.useRef(null);
  const [isSSHModalOpen, setIsSSHModalOpen] = useState(false);
  const [isVSCodeModalOpen, setIsVSCodeModalOpen] = useState(false);
  const [selectedCluster, setSelectedCluster] = useState(null);
  const [workspaceFilter, setWorkspaceFilter] = useState(ALL_WORKSPACES_VALUE);
  const [userFilter, setUserFilter] = useState(ALL_USERS_VALUE);
  const [nameFilter, setNameFilter] = useState('');
  const [showHistory, setShowHistory] = useState(false); // 'active' or 'history'
  const isMobile = useMobile();

  const [filters, setFilters] = useState([]);

  // Handle URL query parameters for workspace and user filtering
  useEffect(() => {
    if (router.isReady) {
      if (router.query.workspace) {
        const workspaceParam = Array.isArray(router.query.workspace)
          ? router.query.workspace[0]
          : router.query.workspace;
        setWorkspaceFilter(workspaceParam);
      }
      if (router.query.user) {
        const userParam = Array.isArray(router.query.user)
          ? router.query.user[0]
          : router.query.user;
        setUserFilter(userParam);
      }
      if (router.query.name) {
        const nameParam = Array.isArray(router.query.name)
          ? router.query.name[0]
          : router.query.name;
        setNameFilter(nameParam);
      }
    }
  }, [
    router.isReady,
    router.query.workspace,
    router.query.user,
    router.query.name,
  ]);

  useEffect(() => {
    const fetchFilterData = async () => {
      try {
        // Trigger cache preloading for clusters page and background preload other pages
        await cachePreloader.preloadForPage('clusters');

        // Fetch configured workspaces for the filter dropdown
        const fetchedWorkspacesConfig = await dashboardCache.get(getWorkspaces);
        const configuredWorkspaceNames = Object.keys(fetchedWorkspacesConfig);

        // Fetch all clusters to see if 'default' workspace is implicitly used
        const allClusters = await dashboardCache.get(getClusters);
        const uniqueClusterWorkspaces = [
          ...new Set(
            allClusters
              .map((cluster) => cluster.workspace || 'default')
              .filter((ws) => ws)
          ),
        ];

        // Combine configured workspaces with any actively used 'default' workspace
        const finalWorkspaces = new Set(configuredWorkspaceNames);
        if (
          uniqueClusterWorkspaces.includes('default') &&
          !finalWorkspaces.has('default')
        ) {
          // Add 'default' if it's used by clusters but not in configured list
          // This ensures 'default' appears if relevant, even if not explicitly in skypilot config
        }
        // Ensure all unique cluster workspaces are in the list, especially 'default'
        uniqueClusterWorkspaces.forEach((wsName) =>
          finalWorkspaces.add(wsName)
        );

        // Fetch users for the filter dropdown
        const fetchedUsers = await dashboardCache.get(getUsers);
        const uniqueClusterUsers = [
          ...new Set(
            allClusters
              .map((cluster) => ({
                userId: cluster.user_hash || cluster.user,
                username: cluster.user,
              }))
              .filter((user) => user.userId)
          ).values(),
        ];

        // Combine fetched users with unique cluster users
        const finalUsers = new Map();

        // Add fetched users first
        fetchedUsers.forEach((user) => {
          finalUsers.set(user.userId, {
            userId: user.userId,
            username: user.username,
            display: formatUserDisplay(user.username, user.userId),
          });
        });

        // Add any cluster users not in the fetched list
        uniqueClusterUsers.forEach((user) => {
          if (!finalUsers.has(user.userId)) {
            finalUsers.set(user.userId, {
              userId: user.userId,
              username: user.username,
              display: formatUserDisplay(user.username, user.userId),
            });
          }
        });
      } catch (error) {
        console.error('Error fetching data for filters:', error);
      }
    };

    updateFiltersByURLParams();
    fetchFilterData();
  }, []);

  // Helper function to update URL query parameters
  const updateURLParams = (filters) => {
    const query = { ...router.query };

    console.table(filters);

    let properties = [];
    let operators = [];
    let values = [];
    let conjunctions = [];

    filters.map((filter, _index) => {
      properties.push(filter.property[0] ?? '');
      operators.push(filter.operator);
      values.push(filter.value);
      conjunctions.push(filter.conjunction[0]);
    });

    query.p = properties;
    query.o = operators;
    query.v = values;
    query.c = conjunctions;

    console.table(query);

    // Use replace to avoid adding to browser history for filter changes
    router.replace(
      {
        pathname: router.pathname,
        query,
      },
      undefined,
      { shallow: true }
    );
  };

  const updateFiltersByURLParams = () => {
    const query = { ...router.query };

    const properties = query.p;
    const operators = query.o;
    const values = query.v;
    const conjunctions = query.c;

    if (conjunctions === undefined) {
      return;
    }

    let filters = [];

    const length = Array.isArray(conjunctions) ? conjunctions.length : 1;

    const propertyMap = new Map();
    propertyMap.set('', '');
    propertyMap.set('S', 'Status');
    propertyMap.set('C', 'Cluster');
    propertyMap.set('U', 'User');
    propertyMap.set('W', 'Workspace');
    propertyMap.set('I', 'Infra');

    const conjunctionMap = new Map();
    conjunctionMap.set('A', 'AND');
    conjunctionMap.set('O', 'OR');

    if (length === 1) {
      filters.push({
        property: propertyMap.get(properties),
        operator: operators,
        value: values,
        conjunction: conjunctionMap.get(conjunctions),
      });
    } else {
      for (let i = 0; i < length; i++) {
        filters.push({
          property: propertyMap.get(properties[i]),
          operator: operators[i],
          value: values[i],
          conjunction: conjunctionMap.get(conjunctions[i]),
        });
      }
    }

    console.table(filters);

    setFilters(filters);
  };

  const handleRefresh = () => {
    // Invalidate cache to ensure fresh data is fetched
    dashboardCache.invalidate(getClusters);
    dashboardCache.invalidate(getClusterHistory);
    dashboardCache.invalidate(getWorkspaces);
    dashboardCache.invalidate(getUsers);

    if (refreshDataRef.current) {
      refreshDataRef.current();
    }
  };

  return (
    <>
      <div className="flex items-center justify-between mb-4 h-5">
        <div className="text-base flex items-center">
          <Link
            href="/clusters"
            className="text-sky-blue hover:underline leading-none"
          >
            Sky Clusters
          </Link>

          <div className="flex items-center ml-6 space-x-3">
            <label className="flex items-center cursor-pointer">
              <input
                type="checkbox"
                checked={showHistory}
                onChange={(e) => setShowHistory(e.target.checked)}
                className="sr-only"
              />
              <div
                className={`relative inline-flex h-5 w-9 items-center rounded-full transition-colors ${
                  showHistory ? 'bg-sky-600' : 'bg-gray-300'
                }`}
              >
                <span
                  className={`inline-block h-3 w-3 transform rounded-full bg-white transition-transform ${
                    showHistory ? 'translate-x-5' : 'translate-x-1'
                  }`}
                />
              </div>
              <span className="ml-2 text-sm text-gray-700">
                Show history (Last 30 days)
              </span>
            </label>
          </div>

          <FilterDropdown
            propertyOptions={PROPERTY_OPTIONS}
            operatorOptions={OPERATORS_OPTIONS}
            setFilters={setFilters}
            updateURLParams={updateURLParams}
            placeholder="Filter clusters"
          />
        </div>
        <div className="flex items-center">
          {loading && (
            <div className="flex items-center mr-2">
              <CircularProgress size={15} className="mt-0" />
              <span className="ml-2 text-gray-500">Loading...</span>
            </div>
          )}
          <button
            onClick={handleRefresh}
            disabled={loading}
            className="text-sky-blue hover:text-sky-blue-bright flex items-center"
          >
            <RotateCwIcon className="h-4 w-4 mr-1.5" />
            {!isMobile && <span>Refresh</span>}
          </button>
        </div>
      </div>

      <Filters
        filters={filters}
        setFilters={setFilters}
        updateURLParams={updateURLParams}
      />

      <ClusterTable
        refreshInterval={REFRESH_INTERVAL}
        setLoading={setLoading}
        refreshDataRef={refreshDataRef}
        workspaceFilter={workspaceFilter}
        userFilter={userFilter}
        nameFilter={nameFilter}
        showHistory={showHistory}
        onOpenSSHModal={(cluster) => {
          setSelectedCluster(cluster);
          setIsSSHModalOpen(true);
        }}
        onOpenVSCodeModal={(cluster) => {
          setSelectedCluster(cluster);
          setIsVSCodeModalOpen(true);
        }}
      />

      {/* SSH Instructions Modal */}
      <SSHInstructionsModal
        isOpen={isSSHModalOpen}
        onClose={() => setIsSSHModalOpen(false)}
        cluster={selectedCluster}
      />

      <VSCodeInstructionsModal
        isOpen={isVSCodeModalOpen}
        onClose={() => setIsVSCodeModalOpen(false)}
        cluster={selectedCluster}
      />
    </>
  );
}

export function ClusterTable({
  refreshInterval,
  setLoading,
  refreshDataRef,
  workspaceFilter,
  userFilter,
  nameFilter,
  showHistory,
  onOpenSSHModal,
  onOpenVSCodeModal,
}) {
  const [data, setData] = useState([]);
  const [sortConfig, setSortConfig] = useState({
    key: null,
    direction: 'ascending',
  });
  const [loading, setLocalLoading] = useState(false);
  const [isInitialLoad, setIsInitialLoad] = useState(true);
  const [currentPage, setCurrentPage] = useState(1);
  const [pageSize, setPageSize] = useState(10);

  const fetchData = React.useCallback(async () => {
    setLoading(true);
    setLocalLoading(true);

    try {
      const activeClusters = await dashboardCache.get(getClusters);

      if (showHistory) {
        const historyClusters = await dashboardCache.get(getClusterHistory);
        // Mark clusters as active or historical for UI distinction
        const markedActiveClusters = activeClusters.map((cluster) => ({
          ...cluster,
          isHistorical: false,
        }));
        const markedHistoryClusters = historyClusters.map((cluster) => ({
          ...cluster,
          isHistorical: true,
        }));
        // Combine and remove duplicates (prefer active over historical)
        const combinedData = [...markedActiveClusters];
        markedHistoryClusters.forEach((histCluster) => {
          const existsInActive = activeClusters.some(
            (activeCluster) =>
              (activeCluster.cluster || activeCluster.name) ===
              (histCluster.cluster || histCluster.name)
          );
          if (!existsInActive) {
            combinedData.push(histCluster);
          }
        });
        setData(combinedData);
      } else {
        // Mark active clusters for consistency
        const markedActiveClusters = activeClusters.map((cluster) => ({
          ...cluster,
          isHistorical: false,
        }));
        setData(markedActiveClusters);
      }
    } catch (error) {
      console.error('Error fetching cluster data:', error);
      setData([]);
    }

    setLoading(false);
    setLocalLoading(false);
    setIsInitialLoad(false);
  }, [setLoading, showHistory]);

  // Use useMemo to compute sorted data
  const sortedData = React.useMemo(() => {
    let filteredData = data;
    // Filter by workspace if workspaceFilter is set and not 'ALL_WORKSPACES_VALUE'
    if (workspaceFilter && workspaceFilter !== ALL_WORKSPACES_VALUE) {
      filteredData = filteredData.filter((item) => {
        const itemWorkspace = item.workspace || 'default'; // Treat missing/empty workspace as 'default'
        return itemWorkspace.toLowerCase() === workspaceFilter.toLowerCase();
      });
    }
    // Filter by user if userFilter is set and not 'ALL_USERS_VALUE'
    if (userFilter && userFilter !== ALL_USERS_VALUE) {
      filteredData = filteredData.filter((item) => {
        const itemUserId = item.user_hash || item.user;
        return itemUserId === userFilter;
      });
    }
    // Filter by name if nameFilter is set
    if (nameFilter) {
      filteredData = filterClustersByName(filteredData, nameFilter);
    }
    return sortData(filteredData, sortConfig.key, sortConfig.direction);
  }, [data, sortConfig, workspaceFilter, userFilter, nameFilter]);

  // Expose fetchData to parent component
  React.useEffect(() => {
    if (refreshDataRef) {
      refreshDataRef.current = fetchData;
    }
  }, [refreshDataRef, fetchData]);

  useEffect(() => {
    setData([]);
    let isCurrent = true;

    fetchData();

    const interval = setInterval(() => {
      if (isCurrent) {
        fetchData();
      }
    }, refreshInterval);

    return () => {
      isCurrent = false;
      clearInterval(interval);
    };
  }, [refreshInterval, fetchData]);

  // Reset to first page when data changes
  useEffect(() => {
    setCurrentPage(1);
  }, [data.length]);

  const requestSort = (key) => {
    let direction = 'ascending';
    if (sortConfig.key === key && sortConfig.direction === 'ascending') {
      direction = 'descending';
    }
    setSortConfig({ key, direction });
  };

  const getSortDirection = (key) => {
    if (sortConfig.key === key) {
      return sortConfig.direction === 'ascending' ? ' ↑' : ' ↓';
    }
    return '';
  };

  // Calculate pagination using sortedData
  const totalPages = Math.ceil(sortedData.length / pageSize);
  const startIndex = (currentPage - 1) * pageSize;
  const endIndex = startIndex + pageSize;
  const paginatedData = sortedData.slice(startIndex, endIndex);

  // Page navigation handlers
  const goToPreviousPage = () => {
    setCurrentPage((page) => Math.max(page - 1, 1));
  };

  const goToNextPage = () => {
    setCurrentPage((page) => Math.min(page + 1, totalPages));
  };

  const handlePageSizeChange = (e) => {
    const newSize = parseInt(e.target.value, 10);
    setPageSize(newSize);
    setCurrentPage(1); // Reset to first page when changing page size
  };

  return (
    <div>
      <Card>
        <div className="overflow-x-auto">
          <Table className="min-w-full">
            <TableHeader>
              <TableRow>
                <TableHead
                  className="sortable whitespace-nowrap"
                  onClick={() => requestSort('status')}
                >
                  Status{getSortDirection('status')}
                </TableHead>
                <TableHead
                  className="sortable whitespace-nowrap"
                  onClick={() => requestSort('cluster')}
                >
                  Cluster{getSortDirection('cluster')}
                </TableHead>
                <TableHead
                  className="sortable whitespace-nowrap hidden sm:table-cell"
                  onClick={() => requestSort('user')}
                >
                  User{getSortDirection('user')}
                </TableHead>
                <TableHead
                  className="sortable whitespace-nowrap hidden md:table-cell"
                  onClick={() => requestSort('workspace')}
                >
                  Workspace{getSortDirection('workspace')}
                </TableHead>
                <TableHead
                  className="sortable whitespace-nowrap hidden lg:table-cell"
                  onClick={() => requestSort('infra')}
                >
                  Infra{getSortDirection('infra')}
                </TableHead>
                <TableHead
                  className="sortable whitespace-nowrap hidden xl:table-cell"
                  onClick={() => requestSort('resources_str')}
                >
                  Resources{getSortDirection('resources_str')}
                </TableHead>
                <TableHead
                  className="sortable whitespace-nowrap"
                  onClick={() => requestSort('time')}
                >
                  Started{getSortDirection('time')}
                </TableHead>
                {showHistory && (
                  <TableHead
                    className="sortable whitespace-nowrap hidden lg:table-cell"
                    onClick={() => requestSort('duration')}
                  >
                    Duration{getSortDirection('duration')}
                  </TableHead>
                )}
                <TableHead
                  className="sortable whitespace-nowrap hidden md:table-cell"
                  onClick={() => requestSort('autostop')}
                >
                  Autostop{getSortDirection('autostop')}
                </TableHead>
                <TableHead className="sticky right-0 bg-white">
                  Actions
                </TableHead>
              </TableRow>
            </TableHeader>

            <TableBody>
              {loading && isInitialLoad ? (
                <TableRow>
                  <TableCell
                    colSpan={9}
                    className="text-center py-6 text-gray-500"
                  >
                    <div className="flex justify-center items-center">
                      <CircularProgress size={20} className="mr-2" />
                      <span>Loading...</span>
                    </div>
                  </TableCell>
                </TableRow>
              ) : paginatedData.length > 0 ? (
                paginatedData.map((item, index) => {
                  return (
                    <TableRow key={index}>
                      <TableCell>
                        <StatusBadge status={item.status} />
                      </TableCell>
                      <TableCell>
                        <Link
                          href={`/clusters/${item.isHistorical ? item.cluster_hash : item.cluster || item.name}`}
                          className="text-blue-600"
                        >
                          {item.cluster || item.name}
                        </Link>
                      </TableCell>
                      <TableCell className="hidden sm:table-cell">
                        <UserDisplay
                          username={item.user}
                          userHash={item.user_hash}
                        />
                      </TableCell>
                      <TableCell className="hidden md:table-cell">
                        <Link
                          href="/workspaces"
                          className="text-blue-600 hover:underline"
                        >
                          {item.workspace || 'default'}
                        </Link>
                      </TableCell>
                      <TableCell className="hidden lg:table-cell">
                        <NonCapitalizedTooltip
                          content={item.full_infra || item.infra}
                          className="text-sm text-muted-foreground"
                        >
                          <span>
                            <Link
                              href="/infra"
                              className="text-blue-600 hover:underline"
                            >
                              {item.cloud}
                            </Link>
                            {item.infra.includes('(') && (
                              <span>
                                {' ' +
                                  item.infra.substring(item.infra.indexOf('('))}
                              </span>
                            )}
                          </span>
                        </NonCapitalizedTooltip>
                      </TableCell>
                      <TableCell className="hidden xl:table-cell">
                        <NonCapitalizedTooltip
                          content={
                            item.resources_str_full || item.resources_str
                          }
                          className="text-sm text-muted-foreground"
                        >
                          <span>{item.resources_str}</span>
                        </NonCapitalizedTooltip>
                      </TableCell>
                      <TableCell>
                        <TimestampWithTooltip date={item.time} />
                      </TableCell>
                      {showHistory && (
                        <TableCell className="hidden lg:table-cell">
                          {formatDuration(item.duration)}
                        </TableCell>
                      )}
                      <TableCell className="hidden md:table-cell">
                        {item.isHistorical
                          ? '-'
                          : formatAutostop(item.autostop, item.to_down)}
                      </TableCell>
                      <TableCell className="text-left sticky right-0 bg-white">
                        {!item.isHistorical && (
                          <Status2Actions
                            cluster={item.cluster}
                            status={item.status}
                            onOpenSSHModal={onOpenSSHModal}
                            onOpenVSCodeModal={onOpenVSCodeModal}
                          />
                        )}
                      </TableCell>
                    </TableRow>
                  );
                })
              ) : (
                <TableRow>
                  <TableCell
                    colSpan={9}
                    className="text-center py-6 text-gray-500"
                  >
                    {showHistory ? 'No clusters found' : 'No active clusters'}
                  </TableCell>
                </TableRow>
              )}
            </TableBody>
          </Table>
        </div>
      </Card>

      {/* Pagination controls */}
      {data.length > 0 && (
        <div className="flex justify-end items-center py-2 px-4 text-sm text-gray-700">
          <div className="flex items-center space-x-4">
            <div className="flex items-center">
              <span className="mr-2">Rows per page:</span>
              <div className="relative inline-block">
                <select
                  value={pageSize}
                  onChange={handlePageSizeChange}
                  className="py-1 pl-2 pr-6 appearance-none outline-none cursor-pointer border-none bg-transparent"
                  style={{ minWidth: '40px' }}
                >
                  <option value={10}>10</option>
                  <option value={30}>30</option>
                  <option value={50}>50</option>
                  <option value={100}>100</option>
                  <option value={200}>200</option>
                </select>
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  className="h-4 w-4 text-gray-500 absolute right-0 top-1/2 transform -translate-y-1/2 pointer-events-none"
                  fill="none"
                  viewBox="0 0 24 24"
                  stroke="currentColor"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth={2}
                    d="M19 9l-7 7-7-7"
                  />
                </svg>
              </div>
            </div>
            <div>
              {startIndex + 1} – {Math.min(endIndex, data.length)} of{' '}
              {data.length}
            </div>
            <div className="flex items-center space-x-2">
              <Button
                variant="ghost"
                size="icon"
                onClick={goToPreviousPage}
                disabled={currentPage === 1}
                className="text-gray-500 h-8 w-8 p-0"
              >
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  width="16"
                  height="16"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  strokeWidth="2"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  className="chevron-left"
                >
                  <path d="M15 18l-6-6 6-6" />
                </svg>
              </Button>
              <Button
                variant="ghost"
                size="icon"
                onClick={goToNextPage}
                disabled={currentPage === totalPages || totalPages === 0}
                className="text-gray-500 h-8 w-8 p-0"
              >
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  width="16"
                  height="16"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  strokeWidth="2"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  className="chevron-right"
                >
                  <path d="M9 18l6-6-6-6" />
                </svg>
              </Button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

export const handleVSCodeConnection = (cluster, onOpenVSCodeModal) => {
  if (onOpenVSCodeModal) {
    onOpenVSCodeModal(cluster);
  }
};

const handleConnect = (cluster, onOpenSSHModal) => {
  if (onOpenSSHModal) {
    onOpenSSHModal(cluster);
  } else {
    const uri = `ssh://${cluster}`;
    window.open(uri);
  }
};

// TODO(hailong): The enabled actions are also related to the `cloud` of the cluster
export const enabledActions = (status) => {
  switch (status) {
    case 'RUNNING':
      return ['connect', 'VSCode'];
    default:
      return [];
  }
};

const actionIcons = {
  connect: <Terminal className="w-4 h-4 text-gray-500 inline-block" />,
  VSCode: <SquareCode className="w-4 h-4 text-gray-500 inline-block" />,
};

export function Status2Actions({
  withLabel = false,
  cluster,
  status,
  onOpenSSHModal,
  onOpenVSCodeModal,
}) {
  const actions = enabledActions(status);
  const isMobile = useMobile();

  const handleActionClick = (actionName) => {
    switch (actionName) {
      case 'connect':
        handleConnect(cluster, onOpenSSHModal);
        break;
      case 'VSCode':
        handleVSCodeConnection(cluster, onOpenVSCodeModal);
        break;
      default:
        return;
    }
  };

  return (
    <>
      <div className="flex items-center space-x-4">
        {Object.entries(actionIcons).map(([actionName, actionIcon]) => {
          let label, tooltipText;
          switch (actionName) {
            case 'connect':
              label = 'Connect';
              tooltipText = 'Connect with SSH';
              break;
            case 'VSCode':
              label = 'VSCode';
              tooltipText = 'Open in VS Code';
              break;
            default:
              break;
          }
          if (!withLabel) {
            label = '';
          }
          if (actions.includes(actionName)) {
            return (
              <Tooltip
                key={actionName}
                content={tooltipText}
                className="capitalize text-sm text-muted-foreground"
              >
                <button
                  onClick={() => handleActionClick(actionName)}
                  className="text-sky-blue hover:text-sky-blue-bright font-medium inline-flex items-center"
                >
                  {actionIcon}
                  {!isMobile && <span className="ml-1.5">{label}</span>}
                </button>
              </Tooltip>
            );
          }
          return (
            <Tooltip
              key={actionName}
              content={tooltipText}
              className="capitalize text-sm text-muted-foreground"
            >
              <span
                className="opacity-30 flex items-center cursor-not-allowed text-sm"
                title={actionName}
              >
                {actionIcon}
                {!isMobile && <span className="ml-1.5">{label}</span>}
              </span>
            </Tooltip>
          );
        })}
      </div>
    </>
  );
}

const FilterDropdown = ({
  propertyOptions = [],
  operatorOptions = [],
  setFilters,
  updateURLParams,
  placeholder = 'Filter clusters',
}) => {
  const inputRef = useRef(null);

  const [isOpen, setIsOpen] = useState(false);
  const [step, setStep] = useState(1);

  const [value, setValue] = useState('');
  const [propertyValue, setPropertValue] = useState('');
  const [operateValue, setOperateValue] = useState('');

  const filteredOptions = !propertyValue
    ? propertyOptions.filter((item) =>
        item?.value?.includes(value.toLowerCase())
      )
    : operatorOptions;

  const handleValueChange = (e) => {
    const newValue = e.target.value;
    if (!propertyValue) {
      setValue(newValue);
    } else {
      if (!operateValue) {
        if (newValue !== propertyValue) {
          setPropertValue('');
          setValue(newValue);
          setIsOpen(true);
          setStep(1);
        }
      } else {
        if (newValue.length < propertyValue.length + operateValue.length) {
          setOperateValue('');
          setValue(propertyValue);
          setIsOpen(true);
          setStep(2);
        } else {
          setValue(newValue);
        }
      }
    }
  };

  const handleRemoveFilterValue = () => {
    setValue('');
    setPropertValue('');
    setOperateValue('');
  };

  const handleSetFilters = () => {
    const filterValue = operateValue ? value.split(operateValue)[1] : value;

    if (filterValue === '') {
      return;
    }

    setFilters((prevFilters) => {
      const updatedFilters = [
        ...prevFilters,
        {
          property: operateValue ? propertyValue : '',
          operator: operateValue,
          value: filterValue,
          conjunction: 'AND',
        },
      ];

      updateURLParams(updatedFilters);

      return updatedFilters;
    });

    setStep(1);
    handleRemoveFilterValue();
    inputRef.current.blur();
  };

  return (
    <>
      <div className="relative ml-4 mr-2">
        <input
          type="text"
          ref={inputRef}
          placeholder={placeholder}
          value={value}
          onChange={(e) => handleValueChange(e)}
          onBlur={() => setIsOpen(false)}
          onFocus={() => setIsOpen(true)}
          onKeyDown={(e) => {
            if (e.key === 'Enter') {
              handleSetFilters();
            }
          }}
          className="h-8 w-32 sm:w-96 px-3 pr-8 text-sm border border-gray-300 rounded-md focus:ring-1 focus:ring-sky-500 focus:border-sky-500 outline-none"
          autoComplete="off"
        />
        {value && (
          <button
            onClick={() => {
              handleRemoveFilterValue();
              setStep(1);
            }}
            className="absolute right-2 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-gray-600"
            title="Clear filter"
            tabIndex={-1}
          >
            <svg
              className="h-4 w-4"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M6 18L18 6M6 6l12 12"
              />
            </svg>
          </button>
        )}
        {isOpen && (
          <div className="flex flex-col absolute z-10 mt-1 w-full bg-white border border-gray-200 rounded-md shadow-lg">
            {value && (
              <span
                className="px-2 py-2 border-b font-semibold text-sm hover:cursor-pointer"
                onMouseDown={(e) => {
                  e.preventDefault();
                  handleSetFilters();
                }}
              >
                Use: "{value}"
              </span>
            )}
            {filteredOptions.length > 0 && (
              <span className="px-2 py-2 border-b font-semibold text-sm">
                {step == 1 ? 'Property' : 'Operator'}
              </span>
            )}
            {filteredOptions.map((option, index) => (
              <div
                key={option.value}
                className={`flex flex-col pl-6 py-2 cursor-pointer hover:bg-sky-50 text-sm ${index != filteredOptions.length - 1} && border-b`}
                onMouseDown={(e) => {
                  e.preventDefault();
                  if (step === 1) {
                    setValue(option.label);
                    setPropertValue(option.label);
                    setStep(2);
                  } else if (step === 2) {
                    const updatedValue = value + option.label;
                    setValue(updatedValue);
                    setOperateValue(option.label);
                    setIsOpen(false);
                    setStep(3);
                  }
                }}
              >
                <span>
                  {propertyValue && (
                    <span className="text-blue-500 font-semibold">
                      {propertyValue}{' '}
                    </span>
                  )}
                  {option.label}
                </span>
                {step == 2 && (
                  <span className="text-xs text-gray-600">{option.value}</span>
                )}
              </div>
            ))}
          </div>
        )}
      </div>
    </>
  );
};

const Filters = ({ filters = [], setFilters, updateURLParams }) => {
  const onConjuntionChange = (newValue, index) => {
    setFilters((prevFilters) => {
      const updatedFilters = prevFilters.map((filter, _index) => {
        if (_index === index) {
          return {
            ...filter,
            conjunction: newValue,
          };
        }

        return filter;
      });

      updateURLParams(updatedFilters);

      return updatedFilters;
    });
  };

  const onRemove = (index) => {
    setFilters((prevFilters) => {
      const updatedFilters = prevFilters.filter(
        (_, _index) => _index !== index
      );

      updateURLParams(updatedFilters);

      return updatedFilters;
    });
  };

  const clearFilters = () => {
    updateURLParams([]);
    setFilters([]);
  };

  return (
    <>
      <div className="flex items-center gap-4 p-2">
        <div className="flex flex-wrap items-content gap-2">
          {filters.map((filter, _index) => (
            <FilterItem
              key={`filteritem-${_index}`}
              filter={filter}
              onConjuntionChange={(newValue) =>
                onConjuntionChange(newValue, _index)
              }
              onRemove={() => onRemove(_index)}
              index={_index}
            />
          ))}
        </div>

        {filters.length > 0 && (
          <>
            <div className="border border-gray-400 h-8"></div>
            <button
              onClick={clearFilters}
              className="border-2 border-blue-600 rounded-full px-4 py-1 text-blue-600 hover:bg-blue-50"
            >
              Clear filters
            </button>
          </>
        )}
      </div>
    </>
  );
};

const FilterItem = ({ filter, onConjuntionChange, onRemove, index }) => {
  const CONJUCTION_OPTIONS = ['AND', 'OR'];

  const [showDropdown, setShowDropdown] = useState(false);

  return (
    <>
      <div className="flex items-center border-2 border-blue-600 rounded-lg">
        <div className="relative">
          {index > 0 && (
            <button
              onClick={() => setShowDropdown((prev) => !prev)}
              className="px-2 py-1 flex items-center border-r-2 border-r-blue-600"
            >
              <div>{filter.conjunction}</div>
              {showDropdown ? (
                <svg
                  className="h-4 w-4 ml-1"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth={2}
                    d="M5 15l7-7 7 7"
                  />
                </svg>
              ) : (
                <svg
                  className="h-4 w-4 ml-1"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth={2}
                    d="M19 9l-7 7-7-7"
                  />
                </svg>
              )}
            </button>
          )}

          {showDropdown && (
            <ul className="absolute z-10 mt-1 w-full bg-white border border-gray-300 rounded shadow">
              {CONJUCTION_OPTIONS.map((option, idx) => (
                <li
                  key={idx}
                  onClick={() => {
                    onConjuntionChange(option);
                    setShowDropdown(false);
                  }}
                  className="px-3 py-2 hover:bg-gray-100 cursor-pointer"
                >
                  {option}
                </li>
              ))}
            </ul>
          )}
        </div>

        <div
          className={`flex items-center px-2 py-1 border-r-2 border-r-blue-600 bg-blue-50 ${index == 0 ? 'rounded-l-lg' : ''}`}
        >
          {filter.property}
          {` ${filter.operator} `}
          {filter.value}
        </div>

        <button
          onClick={() => onRemove()}
          className="p-1 transform text-gray-400 hover:text-gray-600 bg-blue-50 rounded-r-lg"
          title="Clear filter"
        >
          <svg
            className="h-6 w-6"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M6 18L18 6M6 6l12 12"
            />
          </svg>
        </button>
      </div>
    </>
  );
};
