name: demo-deploy

on:
  workflow_dispatch:
    inputs:
      deployment_target:
        description: 'Target deployment (staging or demo)'
        required: true
        type: choice
        options:
          - 'skypilot-demo'
          - 'skypilot-demo-staging'
        default: 'skypilot-demo-staging'

      skip_rebase:
        description: 'Skip rebase with upstream skypilot master (only works for skypilot-demo-staging)'
        required: false
        type: boolean
        default: false
      clean_deploy:
        description: 'Delete namespace before deployment for clean install'
        required: false
        type: boolean
        default: true
      branch:
        description: 'Branch to deploy from (only works for skypilot-demo-staging, if you are deploying skypilot-demo, then staging-deployed-latest will be used and not modifiable - this is the cutoff that deployed to staging)'
        required: true
        type: string
        default: 'demo'

env:
  REGISTRY: us-central1-docker.pkg.dev
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  CLUSTER_ZONE: us-central1-a

permissions:
  id-token: write
  contents: write

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout selected branch from current repository
        if: ${{ inputs.deployment_target == 'skypilot-demo-staging' }}
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.branch }}
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Git and merge with upstream master
        if: ${{ inputs.deployment_target == 'skypilot-demo-staging' && !inputs.skip_rebase }}
        run: |
          # Configure git
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          # Add upstream remote
          git remote add upstream https://github.com/skypilot-org/skypilot.git
          # Fetch upstream master
          git fetch upstream master
          # Rebase demo branch on top of upstream master
          echo "Rebasing demo branch on upstream/master..."
          if ! git rebase upstream/master; then
            echo "‚ùå Rebase failed! There may be conflicts that need manual resolution."
            echo "Please resolve conflicts manually and update the demo branch."
            exit 1
          fi
          # Show current status
          echo "‚úÖ Rebase completed successfully!"
          echo "Current branch and commit:"
          git branch -v
          git log --oneline -5

      - name: Checkout verified source code for demo deployment
        if: ${{ inputs.deployment_target == 'skypilot-demo' }}
        uses: actions/checkout@v4
        with:
          ref: staging-deployed-latest
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        id: auth
        with:
          token_format: 'access_token'
          workload_identity_provider: 'projects/${{ secrets.GCP_PROJECT_NUMBER }}/locations/global/workloadIdentityPools/github-pool/providers/github-provider'
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT_NAME }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Install gcloud CLI
        uses: google-github-actions/setup-gcloud@v2
        with:
          version: 'latest'

      - name: Install GKE gcloud auth plugin
        run: |
          gcloud components install gke-gcloud-auth-plugin
      - name: Install Helm
        uses: azure/setup-helm@v3
        with:
          version: 'latest'

      - name: Configure Docker for Google Cloud
        run: |
          gcloud auth configure-docker ${{ env.REGISTRY }}
      - name: Login to Artifact Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: oauth2accesstoken
          password: ${{ steps.auth.outputs.access_token }}

      - name: Determine cluster name
        id: cluster
        run: |
          if [ "${{ inputs.deployment_target }}" == "skypilot-demo-staging" ]; then
            CLUSTER_NAME="skypilot-demo-2"
          else
            CLUSTER_NAME="skypilot-demo"
          fi
          echo "cluster_name=$CLUSTER_NAME" >> $GITHUB_OUTPUT
          echo "Using cluster: $CLUSTER_NAME"

      - name: Configure kubectl for cluster
        run: |
          gcloud container clusters get-credentials ${{ steps.cluster.outputs.cluster_name }} --zone=${{ env.CLUSTER_ZONE }} --project=${{ secrets.GCP_PROJECT_ID }}
      - name: Determine image tag and repository
        id: version
        run: |
          # Always build new image for each deployment target
          TAG=$(date +%Y%m%d)

          if [ "${{ inputs.deployment_target }}" == "skypilot-demo-staging" ]; then
            REPO="skypilot-demo-staging"
          else
            REPO="skypilot-demo"
          fi

          DOCKER_IMAGE="${{ env.REGISTRY }}/${{ secrets.GCP_PROJECT_ID }}/$REPO/demo:$TAG"
          echo "Repository: $REPO, Tag: $TAG"
          echo "Docker image: $DOCKER_IMAGE"
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "docker_image=$DOCKER_IMAGE" >> $GITHUB_OUTPUT
      - name: Build and push Docker image
        if: ${{ inputs.deployment_target == 'skypilot-demo-staging' }}
        run: |
          DOCKER_IMAGE="${{ steps.version.outputs.docker_image }}"
          echo "Building and pushing Docker image: $DOCKER_IMAGE"
          # Use regular docker build and push to avoid buildx issues
          docker build -t $DOCKER_IMAGE -f Dockerfile .
          docker push $DOCKER_IMAGE

      - name: Get existing image from staging deployment
        if: ${{ inputs.deployment_target == 'skypilot-demo' }}
        id: staging_image
        run: |
          echo "Getting current image from skypilot-demo-staging deployment..."
          # Switch to staging cluster to get the image
          echo "Connecting to staging cluster (skypilot-demo-2)..."
          gcloud container clusters get-credentials skypilot-demo-2 --zone=${{ env.CLUSTER_ZONE }} --project=${{ secrets.GCP_PROJECT_ID }}

          # Get the current image from the staging deployment
          STAGING_IMAGE=$(kubectl get deployment skypilot-demo-staging-api-server -n skypilot-demo-staging -o jsonpath='{.spec.template.spec.containers[0].image}' 2>/dev/null || echo "")

          if [ -z "$STAGING_IMAGE" ]; then
            echo "‚ùå No staging deployment found. Please run skypilot-demo-staging first."
            exit 1
          fi

          echo "‚úÖ Using existing image from staging: $STAGING_IMAGE"
          echo "staging_image=$STAGING_IMAGE" >> $GITHUB_OUTPUT

          # Switch back to demo cluster for deployment
          echo "Switching back to demo cluster (skypilot-demo)..."
          gcloud container clusters get-credentials skypilot-demo --zone=${{ env.CLUSTER_ZONE }} --project=${{ secrets.GCP_PROJECT_ID }}
      - name: Save source code for demo deployment
        if: ${{ inputs.deployment_target == 'skypilot-demo-staging' }}
        run: |
          # Create a branch to store the verified code
          BRANCH_NAME="staging-deployed-latest"
          echo "Creating/updating branch: $BRANCH_NAME"

          # Configure git
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"

          # Create and push the branch
          git checkout -b "$BRANCH_NAME"
          git push origin "$BRANCH_NAME" --force

          echo "‚úÖ Source code saved to branch: $BRANCH_NAME"
          echo "This branch will be used for demo deployment"
      - name: Build Helm dependencies
        run: |
          # Build main skypilot chart dependencies first
          cd charts/skypilot
          helm dependency build
          # Build demo chart dependencies
          cd ../../demo/charts/skypilot-demo
          helm dependency build
      - name: Check deployment mode
        run: |
          if [ "${{ inputs.clean_deploy }}" == "true" ]; then
            echo "üßπ Clean deploy mode: Will delete existing namespace"
          else
            echo "üîÑ Upgrade mode: Will preserve existing namespace and upgrade in place"
          fi
      - name: Clean up existing namespace
        if: ${{ inputs.clean_deploy }}
        run: |
          echo "Clean deploy enabled - deleting existing namespace: ${{ inputs.deployment_target }}"
          # Clean up validatingwebhookconfiguration for staging deployment
          if [ "${{ inputs.deployment_target }}" == "skypilot-demo-staging" ]; then
            echo "Cleaning up validatingwebhookconfiguration for staging deployment..."
            kubectl delete validatingwebhookconfiguration skypilot-demo-staging-ingress-nginx-admission --ignore-not-found=true
          fi
          kubectl delete namespace ${{ inputs.deployment_target }} --ignore-not-found=true
          # Wait for namespace to be fully deleted
          kubectl wait --for=delete namespace/${{ inputs.deployment_target }} --timeout=300s || true
      - name: Deploy to Kubernetes using Helm
        run: |
          # Determine which image to use
          if [ "${{ inputs.deployment_target }}" == "skypilot-demo-staging" ]; then
            DOCKER_IMAGE="${{ steps.version.outputs.docker_image }}"
            echo "Using newly built image: $DOCKER_IMAGE"
          else
            DOCKER_IMAGE="${{ steps.staging_image.outputs.staging_image }}"
            echo "Using existing image from staging: $DOCKER_IMAGE"
          fi

          TAG="${{ steps.version.outputs.tag }}"
          echo "Deploying to cluster: ${{ steps.cluster.outputs.cluster_name }}"
          echo "Namespace: ${{ inputs.deployment_target }}"
          echo "Release: ${{ inputs.deployment_target }}"
          echo "üöÄ Deploying ${{ inputs.deployment_target }}..."
          helm upgrade --install ${{ inputs.deployment_target }} ./demo/charts/skypilot-demo \
            --namespace ${{ inputs.deployment_target }} \
            --values demo/charts/skypilot-demo/values.yaml \
            --set skypilot.apiService.image=$DOCKER_IMAGE \
            --set skypilot.apiService.skipResourceCheck=true \
            --set skypilot.apiService.upgradeStrategy=Recreate \
            --set skypilot.ingress-nginx.enabled=true \
            --set "skypilot.apiService.extraVolumes[0].configMap.name=${{ inputs.deployment_target }}-demo-users" \
            --set "skypilot.apiService.extraVolumes[1].configMap.name=${{ inputs.deployment_target }}-demo-clusters" \
            --set "skypilot.apiService.extraVolumes[2].configMap.name=${{ inputs.deployment_target }}-demo-jobs" \
            --set "skypilot.apiService.extraVolumes[3].configMap.name=${{ inputs.deployment_target }}-demo-cluster-jobs" \
            --set "skypilot.apiService.extraVolumes[4].configMap.name=${{ inputs.deployment_target }}-demo-volumes" \
            --set "skypilot.apiService.extraVolumes[5].configMap.name=${{ inputs.deployment_target }}-demo-workspaces" \
            --set "skypilot.apiService.extraVolumes[6].configMap.name=${{ inputs.deployment_target }}-demo-infrastructure" \
            --create-namespace \
            --wait
      - name: Get external access information
        run: |
          echo "Getting external IP..."
          # Set timeout and check interval
          TIMEOUT=300  # 5 minutes
          INTERVAL=10  # 10 seconds
          START_TIME=$(date +%s)
          # Each deployment target uses its own nginx controller
          SERVICE_NAME="${{ inputs.deployment_target }}-ingress-nginx-controller"
          NAMESPACE="${{ inputs.deployment_target }}"
          ACCESS_PATH="/dashboard"
          echo "Getting external IP for ${{ inputs.deployment_target }}..."
          # Check if service exists
          if ! kubectl get svc $SERVICE_NAME -n $NAMESPACE >/dev/null 2>&1; then
            echo "‚ùå Service $SERVICE_NAME not found in namespace $NAMESPACE"
            exit 1
          fi
          # Event-based polling with timeout
          while true; do
            CURRENT_TIME=$(date +%s)
            ELAPSED=$((CURRENT_TIME - START_TIME))
            # Check if timeout reached
            if [ $ELAPSED -ge $TIMEOUT ]; then
              echo "‚è∞ Timeout reached (${TIMEOUT}s). External IP not available yet."
              echo "‚ö†Ô∏è  You can check later with:"
              echo "kubectl get svc $SERVICE_NAME -n $NAMESPACE"
              echo "üí° The service may take longer to get an external IP assigned."
              echo "‚ùå Deployment failed: External IP not assigned within timeout period."
              exit 1
            fi
            # Check for external IP
            EXTERNAL_IP=$(kubectl get svc $SERVICE_NAME -n $NAMESPACE -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
            if [ -n "$EXTERNAL_IP" ] && [ "$EXTERNAL_IP" != "null" ]; then
              echo "‚úÖ External IP found: $EXTERNAL_IP (after ${ELAPSED}s)"
              echo "üöÄ Access dashboard at: http://$EXTERNAL_IP$ACCESS_PATH/"
              break
            else
              echo "‚è≥ Waiting for external IP... (${ELAPSED}s/${TIMEOUT}s)"
              sleep $INTERVAL
            fi
          done
          echo ""
          echo "‚úÖ Demo deployment completed successfully!"
          echo "Cluster: ${{ steps.cluster.outputs.cluster_name }}"
          echo "Branch: ${{ inputs.branch }}"
          if [ "${{ inputs.deployment_target }}" == "skypilot-demo-staging" ]; then
            echo "Image: ${{ steps.version.outputs.docker_image }} (newly built)"
          else
            echo "Image: ${{ steps.staging_image.outputs.staging_image }} (reused from staging)"
          fi
          echo "Namespace: ${{ inputs.deployment_target }}"
          echo "Mode: ${{ inputs.clean_deploy && 'Clean deploy' || 'Upgrade deploy' }}"
          echo "Access via: http://$EXTERNAL_IP$ACCESS_PATH/"
