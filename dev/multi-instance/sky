#!/bin/bash
# Wrapper script that runs sky commands inside the isolated Docker container.
#
# This simply does: docker exec -it <container> sky "$@"
# The container must be started first with start-container.sh

set -e

# Find instance directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Check if we're running from .sky-dev/bin/ or dev/multi-instance/
if [[ -f "$SCRIPT_DIR/../.instance" ]]; then
    # Running from .sky-dev/bin/
    INSTANCE_DIR="$(dirname "$SCRIPT_DIR")"
elif [[ -f "$SCRIPT_DIR/../../.sky-dev/.instance" ]]; then
    # Running from dev/multi-instance/
    INSTANCE_DIR="$SCRIPT_DIR/../../.sky-dev"
else
    echo "ERROR: Cannot find instance configuration." >&2
    echo "Run setup.sh first, then use the wrapper from .sky-dev/bin/" >&2
    exit 1
fi

# Load instance configuration
source "$INSTANCE_DIR/.instance"

CONTAINER_NAME="skypilot-dev-${INSTANCE_NAME}"

# Check if container is running
if ! docker container inspect -f '{{.State.Running}}' "$CONTAINER_NAME" 2>/dev/null | grep -q true; then
    echo "Container not running. Starting it..."
    "$INSTANCE_DIR/bin/start-container"
fi

# Determine if we need interactive mode
# Use -it for most commands, but not when piping
DOCKER_FLAGS="-i"
if [[ -t 0 ]] && [[ -t 1 ]]; then
    DOCKER_FLAGS="-it"
fi

# Run the command in the container
exec docker exec $DOCKER_FLAGS \
    -w /app \
    "$CONTAINER_NAME" \
    /app/.sky-dev/venv/bin/sky "$@"
