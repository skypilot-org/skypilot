{"version":3,"names":["_is","require","_isValidIdentifier","_helperValidatorIdentifier","_helperStringParser","_index","_utils","classMethodOrPropertyUnionShapeCommon","allowPrivateName","unionShape","discriminator","shapes","name","value","properties","key","validate","assertNodeType","exports","defineType","defineAliasedType","fields","elements","arrayOf","assertNodeOrValueType","default","process","env","BABEL_TYPES_8_BREAKING","undefined","visitor","aliases","operator","assertValueType","Object","assign","identifier","assertOneOf","ASSIGNMENT_OPERATORS","pattern","node","val","validator","is","left","oneOf","right","builder","BINARY_OPERATORS","expression","inOp","oneOfNodeTypes","directives","arrayOfType","body","validateArrayOfType","label","optional","callee","arguments","typeArguments","typeParameters","param","test","consequent","alternate","program","comments","each","assertEach","tokens","type","init","update","functionCommon","params","generator","async","functionTypeAnnotationCommon","returnType","functionDeclarationCommon","declare","id","predicate","parent","inherits","patternLikeCommon","typeAnnotation","decorators","chain","isValidIdentifier","TypeError","match","exec","toString","parentKey","nonComp","computed","imported","meta","isKeyword","isReservedWord","deprecatedAlias","Number","isFinite","error","Error","flags","invalid","LOGICAL_OPERATORS","property","object","normal","sourceType","interpreter","kind","shorthand","argument","listKey","index","length","expressions","discriminant","cases","block","handler","finalizer","prefix","UNARY_OPERATORS","UPDATE_OPERATORS","declarations","withoutInit","constOrLetOrVar","usingOrAwaitUsing","parentIsForX","decl","definite","superClass","implements","mixins","abstract","importAttributes","attributes","assertions","deprecated","source","exportKind","validateOptional","declaration","validateType","specifiers","sourced","sourceless","local","exported","lval","await","module","phase","importKind","options","classMethodOrPropertyCommon","accessibility","static","override","classMethodOrDeclareMethodCommon","access","tag","quasi","assertShape","raw","cooked","templateElementCookedValidator","unterminatedCalled","str","firstInvalidLoc","readStringContents","unterminated","strictNumericEscape","invalidEscapeSequence","numericSeparatorInEscapeSequence","unexpectedNumericSeparator","invalidDigit","invalidCodePoint","tail","quasis","delegate","assertOptionalChainStart","readonly","variance"],"sources":["../../src/definitions/core.ts"],"sourcesContent":["import is from \"../validators/is.ts\";\nimport isValidIdentifier from \"../validators/isValidIdentifier.ts\";\nimport { isKeyword, isReservedWord } from \"@babel/helper-validator-identifier\";\nimport type * as t from \"../index.ts\";\nimport { readStringContents } from \"@babel/helper-string-parser\";\n\nimport {\n  BINARY_OPERATORS,\n  LOGICAL_OPERATORS,\n  ASSIGNMENT_OPERATORS,\n  UNARY_OPERATORS,\n  UPDATE_OPERATORS,\n} from \"../constants/index.ts\";\n\nimport {\n  defineAliasedType,\n  assertShape,\n  assertOptionalChainStart,\n  assertValueType,\n  assertNodeType,\n  assertNodeOrValueType,\n  assertEach,\n  chain,\n  assertOneOf,\n  validateOptional,\n  arrayOf,\n  arrayOfType,\n  validateArrayOfType,\n  validateType,\n  type Validator,\n  type ValidatorImpl,\n  type ValidatorOneOfNodeTypes,\n  type ValidatorType,\n} from \"./utils.ts\";\n\nexport const classMethodOrPropertyUnionShapeCommon = (\n  allowPrivateName = false,\n) => ({\n  unionShape: {\n    discriminator: \"computed\",\n    shapes: [\n      {\n        name: \"computed\",\n        value: [true],\n        properties: {\n          key: {\n            validate: assertNodeType(\"Expression\"),\n          },\n        },\n      },\n      {\n        name: \"nonComputed\",\n        value: [false],\n        properties: {\n          key: {\n            validate: allowPrivateName\n              ? assertNodeType(\n                  \"Identifier\",\n                  \"StringLiteral\",\n                  \"NumericLiteral\",\n                  \"BigIntLiteral\",\n                  \"PrivateName\",\n                )\n              : assertNodeType(\n                  \"Identifier\",\n                  \"StringLiteral\",\n                  \"NumericLiteral\",\n                  \"BigIntLiteral\",\n                ),\n          },\n        },\n      },\n    ],\n  },\n});\n\nconst defineType = defineAliasedType(\"Standardized\");\n\ndefineType(\"ArrayExpression\", {\n  fields: {\n    elements: {\n      validate: arrayOf(\n        assertNodeOrValueType(\"null\", \"Expression\", \"SpreadElement\"),\n      ),\n      default:\n        !process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n          ? []\n          : undefined,\n    },\n  },\n  visitor: [\"elements\"],\n  aliases: [\"Expression\"],\n});\n\ndefineType(\"AssignmentExpression\", {\n  fields: {\n    operator: {\n      validate:\n        !process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n          ? assertValueType(\"string\")\n          : Object.assign(\n              (function () {\n                const identifier = assertOneOf(...ASSIGNMENT_OPERATORS);\n                const pattern = assertOneOf(\"=\");\n\n                return function (node: t.AssignmentExpression, key, val) {\n                  const validator = is(\"Pattern\", node.left)\n                    ? pattern\n                    : identifier;\n                  validator(node, key, val);\n                } satisfies ValidatorImpl;\n              })(),\n              { oneOf: ASSIGNMENT_OPERATORS },\n            ),\n    },\n    left: {\n      validate:\n        !process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n          ? assertNodeType(\"LVal\", \"OptionalMemberExpression\")\n          : assertNodeType(\n              \"Identifier\",\n              \"MemberExpression\",\n              \"OptionalMemberExpression\",\n              \"ArrayPattern\",\n              \"ObjectPattern\",\n              \"TSAsExpression\",\n              \"TSSatisfiesExpression\",\n              \"TSTypeAssertion\",\n              \"TSNonNullExpression\",\n            ),\n    },\n    right: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Expression\"],\n});\n\ndefineType(\"BinaryExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  fields: {\n    operator: {\n      validate: assertOneOf(...BINARY_OPERATORS),\n    },\n    left: {\n      validate: (function () {\n        const expression = assertNodeType(\"Expression\");\n        const inOp = assertNodeType(\"Expression\", \"PrivateName\");\n\n        const validator: ValidatorOneOfNodeTypes = Object.assign(\n          function (node: t.BinaryExpression, key, val) {\n            const validator = node.operator === \"in\" ? inOp : expression;\n            validator(node, key, val);\n          } satisfies ValidatorImpl,\n          // todo(ts): can be discriminated union by `operator` property\n          { oneOfNodeTypes: [\"Expression\", \"PrivateName\"] as const },\n        );\n        return validator;\n      })(),\n    },\n    right: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"],\n});\n\ndefineType(\"InterpreterDirective\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: assertValueType(\"string\"),\n    },\n  },\n});\n\ndefineType(\"Directive\", {\n  visitor: [\"value\"],\n  fields: {\n    value: {\n      validate: assertNodeType(\"DirectiveLiteral\"),\n    },\n  },\n});\n\ndefineType(\"DirectiveLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: assertValueType(\"string\"),\n    },\n  },\n});\n\ndefineType(\"BlockStatement\", {\n  builder: [\"body\", \"directives\"],\n  visitor: [\"directives\", \"body\"],\n  fields: {\n    directives: {\n      validate: arrayOfType(\"Directive\"),\n      default: [],\n    },\n    body: validateArrayOfType(\"Statement\"),\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\", \"Statement\"],\n});\n\ndefineType(\"BreakStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: assertNodeType(\"Identifier\"),\n      optional: true,\n    },\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n});\n\ndefineType(\"CallExpression\", {\n  visitor: process.env.BABEL_8_BREAKING\n    ? [\"callee\", \"typeArguments\", \"arguments\"]\n    : [\"callee\", \"typeParameters\", \"typeArguments\", \"arguments\"],\n  builder: [\"callee\", \"arguments\"],\n  aliases: [\"Expression\"],\n  fields: {\n    callee: {\n      validate: assertNodeType(\"Expression\", \"Super\", \"V8IntrinsicIdentifier\"),\n    },\n    arguments: validateArrayOfType(\n      \"Expression\",\n      \"SpreadElement\",\n      \"ArgumentPlaceholder\",\n    ),\n    typeArguments: {\n      validate: process.env.BABEL_8_BREAKING\n        ? assertNodeType(\n            \"TypeParameterInstantiation\",\n            \"TSTypeParameterInstantiation\",\n          )\n        : assertNodeType(\"TypeParameterInstantiation\"),\n      optional: true,\n    },\n    ...(process.env.BABEL_8_BREAKING || process.env.BABEL_TYPES_8_BREAKING\n      ? {}\n      : {\n          optional: {\n            validate: assertValueType(\"boolean\"),\n            optional: true,\n          },\n          typeParameters: {\n            validate: assertNodeType(\"TSTypeParameterInstantiation\"),\n            optional: true,\n          },\n        }),\n  },\n});\n\ndefineType(\"CatchClause\", {\n  visitor: [\"param\", \"body\"],\n  fields: {\n    param: {\n      validate: assertNodeType(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\"),\n      optional: true,\n    },\n    body: {\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n  },\n  aliases: [\"Scopable\", \"BlockParent\"],\n});\n\ndefineType(\"ConditionalExpression\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  fields: {\n    test: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    consequent: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    alternate: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n  aliases: [\"Expression\", \"Conditional\"],\n});\n\ndefineType(\"ContinueStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: assertNodeType(\"Identifier\"),\n      optional: true,\n    },\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n});\n\ndefineType(\"DebuggerStatement\", {\n  aliases: [\"Statement\"],\n});\n\ndefineType(\"DoWhileStatement\", {\n  builder: [\"test\", \"body\"],\n  visitor: [\"body\", \"test\"],\n  fields: {\n    test: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"],\n});\n\ndefineType(\"EmptyStatement\", {\n  aliases: [\"Statement\"],\n});\n\ndefineType(\"ExpressionStatement\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n  aliases: [\"Statement\", \"ExpressionWrapper\"],\n});\n\ndefineType(\"File\", {\n  builder: [\"program\", \"comments\", \"tokens\"],\n  visitor: [\"program\"],\n  fields: {\n    program: {\n      validate: assertNodeType(\"Program\"),\n    },\n    comments: {\n      validate:\n        !process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n          ? Object.assign(() => {}, {\n              each: { oneOfNodeTypes: [\"CommentBlock\", \"CommentLine\"] },\n            })\n          : assertEach(assertNodeType(\"CommentBlock\", \"CommentLine\")),\n      optional: true,\n    },\n    tokens: {\n      // todo(ts): add Token type\n      validate: assertEach(Object.assign(() => {}, { type: \"any\" })),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ForInStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  aliases: [\n    \"Scopable\",\n    \"Statement\",\n    \"For\",\n    \"BlockParent\",\n    \"Loop\",\n    \"ForXStatement\",\n  ],\n  fields: {\n    left: {\n      validate:\n        !process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n          ? assertNodeType(\"VariableDeclaration\", \"LVal\")\n          : assertNodeType(\n              \"VariableDeclaration\",\n              \"Identifier\",\n              \"MemberExpression\",\n              \"ArrayPattern\",\n              \"ObjectPattern\",\n              \"TSAsExpression\",\n              \"TSSatisfiesExpression\",\n              \"TSTypeAssertion\",\n              \"TSNonNullExpression\",\n            ),\n    },\n    right: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n});\n\ndefineType(\"ForStatement\", {\n  visitor: [\"init\", \"test\", \"update\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\"],\n  fields: {\n    init: {\n      validate: assertNodeType(\"VariableDeclaration\", \"Expression\"),\n      optional: true,\n    },\n    test: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n    update: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n});\n\nexport const functionCommon = () => ({\n  params: validateArrayOfType(\"FunctionParameter\"),\n  generator: {\n    default: false,\n  },\n  async: {\n    default: false,\n  },\n});\n\nexport const functionTypeAnnotationCommon = () => ({\n  returnType: {\n    validate: process.env.BABEL_8_BREAKING\n      ? assertNodeType(\"TypeAnnotation\", \"TSTypeAnnotation\")\n      : assertNodeType(\n          \"TypeAnnotation\",\n          \"TSTypeAnnotation\",\n          // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n          \"Noop\",\n        ),\n    optional: true,\n  },\n  typeParameters: {\n    validate: process.env.BABEL_8_BREAKING\n      ? assertNodeType(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\")\n      : assertNodeType(\n          \"TypeParameterDeclaration\",\n          \"TSTypeParameterDeclaration\",\n          // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n          \"Noop\",\n        ),\n    optional: true,\n  },\n});\n\nexport const functionDeclarationCommon = () => ({\n  ...functionCommon(),\n  declare: {\n    validate: assertValueType(\"boolean\"),\n    optional: true,\n  },\n  id: {\n    validate: assertNodeType(\"Identifier\"),\n    optional: true, // May be null for `export default function`\n  },\n});\n\ndefineType(\"FunctionDeclaration\", {\n  builder: [\"id\", \"params\", \"body\", \"generator\", \"async\"],\n  visitor: [\n    \"id\",\n    \"typeParameters\",\n    \"params\",\n    \"predicate\",\n    \"returnType\",\n    \"body\",\n  ],\n  fields: {\n    ...functionDeclarationCommon(),\n    ...functionTypeAnnotationCommon(),\n    body: {\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n    predicate: {\n      validate: assertNodeType(\"DeclaredPredicate\", \"InferredPredicate\"),\n      optional: true,\n    },\n  },\n  aliases: [\n    \"Scopable\",\n    \"Function\",\n    \"BlockParent\",\n    \"FunctionParent\",\n    \"Statement\",\n    \"Pureish\",\n    \"Declaration\",\n  ],\n  validate:\n    !process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n      ? undefined\n      : (function () {\n          const identifier = assertNodeType(\"Identifier\");\n\n          return function (parent, key, node) {\n            if (!is(\"ExportDefaultDeclaration\", parent)) {\n              identifier(node, \"id\", node.id);\n            }\n          };\n        })(),\n});\n\ndefineType(\"FunctionExpression\", {\n  inherits: \"FunctionDeclaration\",\n  aliases: [\n    \"Scopable\",\n    \"Function\",\n    \"BlockParent\",\n    \"FunctionParent\",\n    \"Expression\",\n    \"Pureish\",\n  ],\n  fields: {\n    ...functionCommon(),\n    ...functionTypeAnnotationCommon(),\n    id: {\n      validate: assertNodeType(\"Identifier\"),\n      optional: true,\n    },\n    body: {\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n    predicate: {\n      validate: assertNodeType(\"DeclaredPredicate\", \"InferredPredicate\"),\n      optional: true,\n    },\n  },\n});\n\nexport const patternLikeCommon = () => ({\n  typeAnnotation: {\n    validate: process.env.BABEL_8_BREAKING\n      ? assertNodeType(\"TypeAnnotation\", \"TSTypeAnnotation\")\n      : assertNodeType(\n          \"TypeAnnotation\",\n          \"TSTypeAnnotation\",\n          // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n          \"Noop\",\n        ),\n    optional: true,\n  },\n  optional: {\n    validate: assertValueType(\"boolean\"),\n    optional: true,\n  },\n  decorators: {\n    validate: arrayOfType(\"Decorator\"),\n    optional: true,\n  },\n});\n\ndefineType(\"Identifier\", {\n  builder: [\"name\"],\n  visitor: [\"typeAnnotation\", \"decorators\" /* for legacy param decorators */],\n  aliases: [\n    \"Expression\",\n    \"FunctionParameter\",\n    \"PatternLike\",\n    \"LVal\",\n    \"TSEntityName\",\n  ],\n  fields: {\n    ...patternLikeCommon(),\n    name: {\n      validate:\n        process.env.BABEL_8_BREAKING || process.env.BABEL_TYPES_8_BREAKING\n          ? chain(\n              assertValueType(\"string\"),\n              Object.assign(\n                function (node, key, val) {\n                  if (!isValidIdentifier(val, false)) {\n                    throw new TypeError(\n                      `\"${val}\" is not a valid identifier name`,\n                    );\n                  }\n                } satisfies ValidatorImpl,\n                { type: \"string\" as const },\n              ) satisfies ValidatorType,\n            )\n          : assertValueType(\"string\"),\n    },\n  },\n  validate:\n    process.env.BABEL_8_BREAKING || process.env.BABEL_TYPES_8_BREAKING\n      ? function (parent, key, node) {\n          const match = /\\.(\\w+)$/.exec(key.toString());\n          if (!match) return;\n\n          const [, parentKey] = match;\n          const nonComp = { computed: false };\n\n          // We can't check if `parent.property === node`, because nodes are validated\n          // before replacing them in the AST.\n          if (parentKey === \"property\") {\n            if (is(\"MemberExpression\", parent, nonComp)) return;\n            if (is(\"OptionalMemberExpression\", parent, nonComp)) return;\n          } else if (parentKey === \"key\") {\n            if (is(\"Property\", parent, nonComp)) return;\n            if (is(\"Method\", parent, nonComp)) return;\n          } else if (parentKey === \"exported\") {\n            if (is(\"ExportSpecifier\", parent)) return;\n          } else if (parentKey === \"imported\") {\n            if (is(\"ImportSpecifier\", parent, { imported: node })) return;\n          } else if (parentKey === \"meta\") {\n            if (is(\"MetaProperty\", parent, { meta: node })) return;\n          }\n\n          if (\n            // Ideally we should call isStrictReservedWord if this node is a descendant\n            // of a block in strict mode. Also, we should pass the inModule option so\n            // we can disable \"await\" in module.\n            (isKeyword(node.name) || isReservedWord(node.name, false)) &&\n            // Even if \"this\" is a keyword, we are using the Identifier\n            // node to represent it.\n            node.name !== \"this\"\n          ) {\n            throw new TypeError(`\"${node.name}\" is not a valid identifier`);\n          }\n        }\n      : undefined,\n});\n\ndefineType(\"IfStatement\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  aliases: [\"Statement\", \"Conditional\"],\n  fields: {\n    test: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    consequent: {\n      validate: assertNodeType(\"Statement\"),\n    },\n    alternate: {\n      optional: true,\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n});\n\ndefineType(\"LabeledStatement\", {\n  visitor: [\"label\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    label: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n});\n\ndefineType(\"StringLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: assertValueType(\"string\"),\n    },\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"],\n});\n\ndefineType(\"NumericLiteral\", {\n  builder: [\"value\"],\n  deprecatedAlias: \"NumberLiteral\",\n  fields: {\n    value: {\n      validate: chain(\n        assertValueType(\"number\"),\n        Object.assign(\n          function (node, key, val) {\n            if (1 / val < 0 || !Number.isFinite(val)) {\n              const error = new Error(\n                \"NumericLiterals must be non-negative finite numbers. \" +\n                  `You can use t.valueToNode(${val}) instead.`,\n              );\n              if (process.env.BABEL_8_BREAKING) {\n                // TODO(@nicolo-ribaudo) Fix regenerator to not pass negative\n                // numbers here.\n                if (!IS_STANDALONE) {\n                  if (!new Error().stack.includes(\"regenerator\")) {\n                    throw error;\n                  }\n                }\n              } else {\n                // TODO: Enable this warning once regenerator is fixed.\n                // https://github.com/facebook/regenerator/pull/680\n                // console.warn(error);\n              }\n            }\n          } satisfies ValidatorImpl,\n          { type: \"number\" as const },\n        ) satisfies ValidatorType,\n      ),\n    },\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"],\n});\n\ndefineType(\"NullLiteral\", {\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"],\n});\n\ndefineType(\"BooleanLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: assertValueType(\"boolean\"),\n    },\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"],\n});\n\ndefineType(\"RegExpLiteral\", {\n  builder: [\"pattern\", \"flags\"],\n  deprecatedAlias: \"RegexLiteral\",\n  aliases: [\"Expression\", \"Pureish\", \"Literal\"],\n  fields: {\n    pattern: {\n      validate: assertValueType(\"string\"),\n    },\n    flags: {\n      validate:\n        process.env.BABEL_8_BREAKING || process.env.BABEL_TYPES_8_BREAKING\n          ? chain(\n              assertValueType(\"string\"),\n              Object.assign(\n                function (node, key, val) {\n                  const invalid = /[^dgimsuvy]/.exec(val);\n                  if (invalid) {\n                    throw new TypeError(\n                      `\"${invalid[0]}\" is not a valid RegExp flag`,\n                    );\n                  }\n                } satisfies ValidatorImpl,\n                { type: \"string\" as const },\n              ) satisfies ValidatorType,\n            )\n          : assertValueType(\"string\"),\n      default: \"\",\n    },\n  },\n});\n\ndefineType(\"LogicalExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"],\n  fields: {\n    operator: {\n      validate: assertOneOf(...LOGICAL_OPERATORS),\n    },\n    left: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    right: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\ndefineType(\"MemberExpression\", {\n  builder: [\n    \"object\",\n    \"property\",\n    \"computed\",\n    ...(!process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n      ? [\"optional\"]\n      : []),\n  ],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\", \"LVal\", \"PatternLike\"],\n  unionShape: {\n    discriminator: \"computed\",\n    shapes: [\n      {\n        name: \"computed\",\n        value: [true],\n        properties: {\n          property: {\n            validate: assertNodeType(\"Expression\"),\n          },\n        },\n      },\n      {\n        name: \"nonComputed\",\n        value: [false],\n        properties: {\n          property: {\n            validate: assertNodeType(\"Identifier\", \"PrivateName\"),\n          },\n        },\n      },\n    ],\n  },\n  fields: {\n    object: {\n      validate: assertNodeType(\"Expression\", \"Super\"),\n    },\n    property: {\n      validate: (function () {\n        const normal = assertNodeType(\"Identifier\", \"PrivateName\");\n        const computed = assertNodeType(\"Expression\");\n\n        const validator: ValidatorOneOfNodeTypes = function (\n          node: t.MemberExpression,\n          key,\n          val,\n        ) {\n          const validator: Validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n        // todo(ts): can be discriminated union by `computed` property\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"PrivateName\"];\n        return validator;\n      })(),\n    },\n    computed: {\n      default: false,\n    },\n    ...(!process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n      ? {\n          optional: {\n            validate: assertValueType(\"boolean\"),\n            optional: true,\n          },\n        }\n      : {}),\n  },\n});\n\ndefineType(\"NewExpression\", { inherits: \"CallExpression\" });\n\ndefineType(\"Program\", {\n  // Note: We explicitly leave 'interpreter' out here because it is\n  // conceptually comment-like, and Babel does not traverse comments either.\n  visitor: [\"directives\", \"body\"],\n  builder: [\"body\", \"directives\", \"sourceType\", \"interpreter\"],\n  fields: {\n    sourceType: {\n      validate: assertOneOf(\"script\", \"module\"),\n      default: \"script\",\n    },\n    interpreter: {\n      validate: assertNodeType(\"InterpreterDirective\"),\n      default: null,\n      optional: true,\n    },\n    directives: {\n      validate: arrayOfType(\"Directive\"),\n      default: [],\n    },\n    body: validateArrayOfType(\"Statement\"),\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\"],\n});\n\ndefineType(\"ObjectExpression\", {\n  visitor: [\"properties\"],\n  aliases: [\"Expression\"],\n  fields: {\n    properties: validateArrayOfType(\n      \"ObjectMethod\",\n      \"ObjectProperty\",\n      \"SpreadElement\",\n    ),\n  },\n});\n\ndefineType(\"ObjectMethod\", {\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\", \"generator\", \"async\"],\n  visitor: [\n    \"decorators\",\n    \"key\",\n    \"typeParameters\",\n    \"params\",\n    \"returnType\",\n    \"body\",\n  ],\n  ...classMethodOrPropertyUnionShapeCommon(),\n  fields: {\n    ...functionCommon(),\n    ...functionTypeAnnotationCommon(),\n    kind: {\n      validate: assertOneOf(\"method\", \"get\", \"set\"),\n      ...(!process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n        ? { default: \"method\" }\n        : {}),\n    },\n    computed: {\n      default: false,\n    },\n    key: {\n      validate: (function () {\n        const normal = assertNodeType(\n          \"Identifier\",\n          \"StringLiteral\",\n          \"NumericLiteral\",\n          \"BigIntLiteral\",\n        );\n        const computed = assertNodeType(\"Expression\");\n\n        const validator: ValidatorOneOfNodeTypes = function (\n          node: t.ObjectMethod,\n          key,\n          val,\n        ) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n        // todo(ts): can be discriminated union by `computed` property\n        validator.oneOfNodeTypes = [\n          \"Expression\",\n          \"Identifier\",\n          \"StringLiteral\",\n          \"NumericLiteral\",\n          \"BigIntLiteral\",\n        ];\n        return validator;\n      })(),\n    },\n    decorators: {\n      validate: arrayOfType(\"Decorator\"),\n      optional: true,\n    },\n    body: {\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n  },\n  aliases: [\n    \"UserWhitespacable\",\n    \"Function\",\n    \"Scopable\",\n    \"BlockParent\",\n    \"FunctionParent\",\n    \"Method\",\n    \"ObjectMember\",\n  ],\n});\n\ndefineType(\"ObjectProperty\", {\n  builder: [\n    \"key\",\n    \"value\",\n    \"computed\",\n    \"shorthand\",\n    ...(!process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n      ? [\"decorators\"]\n      : []),\n  ],\n  unionShape: {\n    discriminator: \"computed\",\n    shapes: [\n      {\n        name: \"computed\",\n        value: [true],\n        properties: {\n          key: {\n            validate: assertNodeType(\"Expression\"),\n          },\n        },\n      },\n      {\n        name: \"nonComputed\",\n        value: [false],\n        properties: {\n          key: {\n            validate: process.env.BABEL_8_BREAKING\n              ? assertNodeType(\n                  \"Identifier\",\n                  \"StringLiteral\",\n                  \"NumericLiteral\",\n                  \"BigIntLiteral\",\n                  \"PrivateName\",\n                )\n              : assertNodeType(\n                  \"Identifier\",\n                  \"StringLiteral\",\n                  \"NumericLiteral\",\n                  \"BigIntLiteral\",\n                  // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n                  \"DecimalLiteral\",\n                  \"PrivateName\",\n                ),\n          },\n        },\n      },\n    ],\n  },\n  fields: {\n    computed: {\n      default: false,\n    },\n    key: {\n      validate: (function () {\n        const normal = process.env.BABEL_8_BREAKING\n          ? assertNodeType(\n              \"Identifier\",\n              \"StringLiteral\",\n              \"NumericLiteral\",\n              \"BigIntLiteral\",\n              \"PrivateName\",\n            )\n          : assertNodeType(\n              \"Identifier\",\n              \"StringLiteral\",\n              \"NumericLiteral\",\n              \"BigIntLiteral\",\n              // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n              \"DecimalLiteral\",\n              \"PrivateName\",\n            );\n        const computed = assertNodeType(\"Expression\");\n\n        // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST allows DecimalLiteral\n        const validator: ValidatorOneOfNodeTypes = Object.assign(\n          function (node: t.ObjectProperty, key, val) {\n            const validator = node.computed ? computed : normal;\n            validator(node, key, val);\n          } satisfies ValidatorImpl,\n          {\n            // todo(ts): can be discriminated union by `computed` property\n            oneOfNodeTypes: process.env.BABEL_8_BREAKING\n              ? ([\n                  \"Expression\",\n                  \"Identifier\",\n                  \"StringLiteral\",\n                  \"NumericLiteral\",\n                  \"BigIntLiteral\",\n                  \"PrivateName\",\n                ] as const)\n              : ([\n                  \"Expression\",\n                  \"Identifier\",\n                  \"StringLiteral\",\n                  \"NumericLiteral\",\n                  \"BigIntLiteral\",\n                  \"DecimalLiteral\",\n                  \"PrivateName\",\n                ] as const),\n          },\n        );\n        return validator;\n      })(),\n    },\n    value: {\n      // Value may be PatternLike if this is an AssignmentProperty\n      // https://github.com/babel/babylon/issues/434\n      validate: assertNodeType(\"Expression\", \"PatternLike\"),\n    },\n    shorthand: {\n      validate:\n        process.env.BABEL_8_BREAKING || process.env.BABEL_TYPES_8_BREAKING\n          ? chain(\n              assertValueType(\"boolean\"),\n              Object.assign(\n                function (node: t.ObjectProperty, key, shorthand) {\n                  if (!shorthand) return;\n\n                  if (node.computed) {\n                    throw new TypeError(\n                      \"Property shorthand of ObjectProperty cannot be true if computed is true\",\n                    );\n                  }\n\n                  if (!is(\"Identifier\", node.key)) {\n                    throw new TypeError(\n                      \"Property shorthand of ObjectProperty cannot be true if key is not an Identifier\",\n                    );\n                  }\n                } satisfies ValidatorImpl,\n                { type: \"boolean\" as const },\n              ) satisfies ValidatorType,\n            )\n          : assertValueType(\"boolean\"),\n      default: false,\n    },\n    decorators: {\n      validate: arrayOfType(\"Decorator\"),\n      optional: true,\n    },\n  },\n  visitor: [\"decorators\", \"key\", \"value\"],\n  aliases: [\"UserWhitespacable\", \"Property\", \"ObjectMember\"],\n  validate:\n    !process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n      ? undefined\n      : (function () {\n          const pattern = assertNodeType(\n            \"Identifier\",\n            \"Pattern\",\n            \"TSAsExpression\",\n            \"TSSatisfiesExpression\",\n            \"TSNonNullExpression\",\n            \"TSTypeAssertion\",\n          );\n          const expression = assertNodeType(\"Expression\");\n\n          return function (parent, key, node) {\n            const validator = is(\"ObjectPattern\", parent)\n              ? pattern\n              : expression;\n            validator(node, \"value\", node.value);\n          };\n        })(),\n});\n\ndefineType(\"RestElement\", {\n  visitor: [\"argument\", \"typeAnnotation\"],\n  builder: [\"argument\"],\n  aliases: process.env.BABEL_8_BREAKING\n    ? [\"FunctionParameter\", \"PatternLike\"]\n    : [\"FunctionParameter\", \"PatternLike\", \"LVal\"],\n  deprecatedAlias: \"RestProperty\",\n  fields: {\n    ...patternLikeCommon(),\n    argument: {\n      validate:\n        !process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n          ? assertNodeType(\n              \"Identifier\",\n              \"ArrayPattern\",\n              \"ObjectPattern\",\n              \"MemberExpression\",\n              \"TSAsExpression\",\n              \"TSSatisfiesExpression\",\n              \"TSTypeAssertion\",\n              \"TSNonNullExpression\",\n              // These are not valid in RestElement, but we allow them for backwards compatibility.\n              \"RestElement\",\n              \"AssignmentPattern\",\n            )\n          : assertNodeType(\n              \"Identifier\",\n              \"ArrayPattern\",\n              \"ObjectPattern\",\n              \"MemberExpression\",\n              \"TSAsExpression\",\n              \"TSSatisfiesExpression\",\n              \"TSTypeAssertion\",\n              \"TSNonNullExpression\",\n            ),\n    },\n  },\n  validate:\n    process.env.BABEL_8_BREAKING || process.env.BABEL_TYPES_8_BREAKING\n      ? (function (parent: t.ArrayPattern | t.ObjectPattern, key) {\n          const match = /(\\w+)\\[(\\d+)\\]/.exec(key.toString());\n          if (!match) throw new Error(\"Internal Babel error: malformed key.\");\n\n          const [, listKey, index] = match as unknown as [\n            string,\n            keyof typeof parent,\n            string,\n          ];\n          if ((parent[listKey] as t.Node[]).length > +index + 1) {\n            throw new TypeError(\n              `RestElement must be last element of ${listKey}`,\n            );\n          }\n        } satisfies ValidatorImpl)\n      : undefined,\n});\n\ndefineType(\"ReturnStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"SequenceExpression\", {\n  visitor: [\"expressions\"],\n  fields: {\n    expressions: validateArrayOfType(\"Expression\"),\n  },\n  aliases: [\"Expression\"],\n});\n\ndefineType(\"ParenthesizedExpression\", {\n  visitor: [\"expression\"],\n  aliases: [\"Expression\", \"ExpressionWrapper\"],\n  fields: {\n    expression: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\ndefineType(\"SwitchCase\", {\n  visitor: [\"test\", \"consequent\"],\n  fields: {\n    test: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n    consequent: validateArrayOfType(\"Statement\"),\n  },\n});\n\ndefineType(\"SwitchStatement\", {\n  visitor: [\"discriminant\", \"cases\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Scopable\"],\n  fields: {\n    discriminant: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    cases: validateArrayOfType(\"SwitchCase\"),\n  },\n});\n\ndefineType(\"ThisExpression\", {\n  aliases: process.env.BABEL_8_BREAKING\n    ? [\"Expression\", \"TSEntityName\"]\n    : [\"Expression\"],\n});\n\ndefineType(\"ThrowStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\ndefineType(\"TryStatement\", {\n  visitor: [\"block\", \"handler\", \"finalizer\"],\n  aliases: [\"Statement\"],\n  fields: {\n    block: {\n      validate:\n        process.env.BABEL_8_BREAKING || process.env.BABEL_TYPES_8_BREAKING\n          ? chain(\n              assertNodeType(\"BlockStatement\"),\n              Object.assign(\n                function (node: t.TryStatement) {\n                  // This validator isn't put at the top level because we can run it\n                  // even if this node doesn't have a parent.\n\n                  if (!node.handler && !node.finalizer) {\n                    throw new TypeError(\n                      \"TryStatement expects either a handler or finalizer, or both\",\n                    );\n                  }\n                } satisfies ValidatorImpl,\n                { oneOfNodeTypes: [\"BlockStatement\"] as const },\n              ) satisfies ValidatorOneOfNodeTypes,\n            )\n          : assertNodeType(\"BlockStatement\"),\n    },\n    handler: {\n      optional: true,\n      validate: assertNodeType(\"CatchClause\"),\n    },\n    finalizer: {\n      optional: true,\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n  },\n});\n\ndefineType(\"UnaryExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: true,\n    },\n    argument: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    operator: {\n      validate: assertOneOf(...UNARY_OPERATORS),\n    },\n  },\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\", \"Expression\"],\n});\n\ndefineType(\"UpdateExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: false,\n    },\n    argument: {\n      validate:\n        !process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n          ? assertNodeType(\"Expression\")\n          : assertNodeType(\"Identifier\", \"MemberExpression\"),\n    },\n    operator: {\n      validate: assertOneOf(...UPDATE_OPERATORS),\n    },\n  },\n  visitor: [\"argument\"],\n  aliases: [\"Expression\"],\n});\n\ndefineType(\"VariableDeclaration\", {\n  builder: [\"kind\", \"declarations\"],\n  visitor: [\"declarations\"],\n  aliases: [\"Statement\", \"Declaration\"],\n  fields: {\n    declare: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    kind: {\n      validate: assertOneOf(\n        \"var\",\n        \"let\",\n        \"const\",\n        // https://github.com/tc39/proposal-explicit-resource-management\n        \"using\",\n        // https://github.com/tc39/proposal-async-explicit-resource-management\n        \"await using\",\n      ),\n    },\n    declarations: validateArrayOfType(\"VariableDeclarator\"),\n  },\n  validate:\n    process.env.BABEL_8_BREAKING || process.env.BABEL_TYPES_8_BREAKING\n      ? (() => {\n          const withoutInit = assertNodeType(\"Identifier\", \"Placeholder\");\n          const constOrLetOrVar = assertNodeType(\n            \"Identifier\",\n            \"ArrayPattern\",\n            \"ObjectPattern\",\n            \"Placeholder\",\n          );\n          const usingOrAwaitUsing = assertNodeType(\n            \"Identifier\",\n            \"VoidPattern\",\n            \"Placeholder\",\n          );\n\n          return function (parent, key, node: t.VariableDeclaration) {\n            const { kind, declarations } = node;\n            const parentIsForX = is(\"ForXStatement\", parent, { left: node });\n            if (parentIsForX) {\n              if (declarations.length !== 1) {\n                throw new TypeError(\n                  `Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`,\n                );\n              }\n            }\n            for (const decl of declarations) {\n              if (kind === \"const\" || kind === \"let\" || kind === \"var\") {\n                if (!parentIsForX && !decl.init) {\n                  withoutInit(decl, \"id\", decl.id);\n                } else {\n                  constOrLetOrVar(decl, \"id\", decl.id);\n                }\n              } else {\n                usingOrAwaitUsing(decl, \"id\", decl.id);\n              }\n            }\n          };\n        })()\n      : undefined,\n});\n\ndefineType(\"VariableDeclarator\", {\n  visitor: [\"id\", \"init\"],\n  fields: {\n    id: {\n      validate:\n        !process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n          ? assertNodeType(\"LVal\", \"VoidPattern\")\n          : assertNodeType(\n              \"Identifier\",\n              \"ArrayPattern\",\n              \"ObjectPattern\",\n              \"VoidPattern\",\n            ),\n    },\n    definite: {\n      optional: true,\n      validate: assertValueType(\"boolean\"),\n    },\n    init: {\n      optional: true,\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\ndefineType(\"WhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"],\n  fields: {\n    test: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n});\n\ndefineType(\"WithStatement\", {\n  visitor: [\"object\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    object: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n});\n\n// --- ES2015 ---\ndefineType(\"AssignmentPattern\", {\n  visitor: [\"left\", \"right\", \"decorators\" /* for legacy param decorators */],\n  builder: [\"left\", \"right\"],\n  aliases: process.env.BABEL_8_BREAKING\n    ? [\"FunctionParameter\", \"Pattern\", \"PatternLike\"]\n    : [\"FunctionParameter\", \"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: {\n    ...patternLikeCommon(),\n    left: {\n      validate: assertNodeType(\n        \"Identifier\",\n        \"ObjectPattern\",\n        \"ArrayPattern\",\n        \"MemberExpression\",\n        \"TSAsExpression\",\n        \"TSSatisfiesExpression\",\n        \"TSTypeAssertion\",\n        \"TSNonNullExpression\",\n      ),\n    },\n    right: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    // For TypeScript\n    decorators: {\n      validate: arrayOfType(\"Decorator\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ArrayPattern\", {\n  visitor: [\"elements\", \"typeAnnotation\"],\n  builder: [\"elements\"],\n  aliases: [\"FunctionParameter\", \"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: {\n    ...patternLikeCommon(),\n    elements: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeOrValueType(\"null\", \"PatternLike\")),\n      ),\n    },\n  },\n});\n\ndefineType(\"ArrowFunctionExpression\", {\n  builder: [\"params\", \"body\", \"async\"],\n  visitor: [\"typeParameters\", \"params\", \"predicate\", \"returnType\", \"body\"],\n  aliases: [\n    \"Scopable\",\n    \"Function\",\n    \"BlockParent\",\n    \"FunctionParent\",\n    \"Expression\",\n    \"Pureish\",\n  ],\n  fields: {\n    ...functionCommon(),\n    ...functionTypeAnnotationCommon(),\n    expression: {\n      // https://github.com/babel/babylon/issues/505\n      validate: assertValueType(\"boolean\"),\n    },\n    body: {\n      validate: assertNodeType(\"BlockStatement\", \"Expression\"),\n    },\n    predicate: {\n      validate: assertNodeType(\"DeclaredPredicate\", \"InferredPredicate\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ClassBody\", {\n  visitor: [\"body\"],\n  fields: {\n    body: validateArrayOfType(\n      \"ClassMethod\",\n      \"ClassPrivateMethod\",\n      \"ClassProperty\",\n      \"ClassPrivateProperty\",\n      \"ClassAccessorProperty\",\n      \"TSDeclareMethod\",\n      \"TSIndexSignature\",\n      \"StaticBlock\",\n    ),\n  },\n});\n\ndefineType(\"ClassExpression\", {\n  builder: [\"id\", \"superClass\", \"body\", \"decorators\"],\n  visitor: [\n    \"decorators\",\n    \"id\",\n    \"typeParameters\",\n    \"superClass\",\n    process.env.BABEL_8_BREAKING ? \"superTypeArguments\" : \"superTypeParameters\",\n    \"mixins\",\n    \"implements\",\n    \"body\",\n  ],\n  aliases: [\"Scopable\", \"Class\", \"Expression\"],\n  fields: {\n    id: {\n      validate: assertNodeType(\"Identifier\"),\n      optional: true,\n    },\n    typeParameters: {\n      validate: process.env.BABEL_8_BREAKING\n        ? assertNodeType(\n            \"TypeParameterDeclaration\",\n            \"TSTypeParameterDeclaration\",\n          )\n        : assertNodeType(\n            \"TypeParameterDeclaration\",\n            \"TSTypeParameterDeclaration\",\n            // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n            \"Noop\",\n          ),\n      optional: true,\n    },\n    body: {\n      validate: assertNodeType(\"ClassBody\"),\n    },\n    superClass: {\n      optional: true,\n      validate: assertNodeType(\"Expression\"),\n    },\n    [process.env.BABEL_8_BREAKING\n      ? \"superTypeArguments\"\n      : \"superTypeParameters\"]: {\n      validate: assertNodeType(\n        \"TypeParameterInstantiation\",\n        \"TSTypeParameterInstantiation\",\n      ),\n      optional: true,\n    },\n    implements: {\n      validate: arrayOfType(\n        // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n        process.env.BABEL_8_BREAKING\n          ? \"TSClassImplements\"\n          : \"TSExpressionWithTypeArguments\",\n        \"ClassImplements\",\n      ),\n      optional: true,\n    },\n    decorators: {\n      validate: arrayOfType(\"Decorator\"),\n      optional: true,\n    },\n    mixins: {\n      validate: assertNodeType(\"InterfaceExtends\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ClassDeclaration\", {\n  inherits: \"ClassExpression\",\n  aliases: [\"Scopable\", \"Class\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: {\n      validate: assertNodeType(\"Identifier\"),\n      // The id may be omitted if this is the child of an\n      // ExportDefaultDeclaration.\n      optional: true,\n    },\n    typeParameters: {\n      validate: process.env.BABEL_8_BREAKING\n        ? assertNodeType(\n            \"TypeParameterDeclaration\",\n            \"TSTypeParameterDeclaration\",\n          )\n        : assertNodeType(\n            \"TypeParameterDeclaration\",\n            \"TSTypeParameterDeclaration\",\n            // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n            \"Noop\",\n          ),\n      optional: true,\n    },\n    body: {\n      validate: assertNodeType(\"ClassBody\"),\n    },\n    superClass: {\n      optional: true,\n      validate: assertNodeType(\"Expression\"),\n    },\n    [process.env.BABEL_8_BREAKING\n      ? \"superTypeArguments\"\n      : \"superTypeParameters\"]: {\n      validate: assertNodeType(\n        \"TypeParameterInstantiation\",\n        \"TSTypeParameterInstantiation\",\n      ),\n      optional: true,\n    },\n    implements: {\n      validate: arrayOfType(\n        // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n        process.env.BABEL_8_BREAKING\n          ? \"TSClassImplements\"\n          : \"TSExpressionWithTypeArguments\",\n        \"ClassImplements\",\n      ),\n      optional: true,\n    },\n    decorators: {\n      validate: arrayOfType(\"Decorator\"),\n      optional: true,\n    },\n    mixins: {\n      validate: assertNodeType(\"InterfaceExtends\"),\n      optional: true,\n    },\n    declare: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    abstract: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n  },\n  validate:\n    !process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n      ? undefined\n      : (function () {\n          const identifier = assertNodeType(\"Identifier\");\n          return function (parent, key, node) {\n            if (!is(\"ExportDefaultDeclaration\", parent)) {\n              identifier(node, \"id\", node.id);\n            }\n          };\n        })(),\n});\n\nexport const importAttributes = {\n  attributes: {\n    optional: true,\n    validate: arrayOfType(\"ImportAttribute\"),\n  },\n  assertions: {\n    deprecated: true,\n    optional: true,\n    validate: arrayOfType(\"ImportAttribute\"),\n  },\n};\n\ndefineType(\"ExportAllDeclaration\", {\n  builder: [\"source\"],\n  visitor: [\"source\", \"attributes\", \"assertions\"],\n  aliases: [\n    \"Statement\",\n    \"Declaration\",\n    \"ImportOrExportDeclaration\",\n    \"ExportDeclaration\",\n  ],\n  fields: {\n    source: {\n      validate: assertNodeType(\"StringLiteral\"),\n    },\n    exportKind: validateOptional(assertOneOf(\"type\", \"value\")),\n    ...importAttributes,\n  },\n});\n\ndefineType(\"ExportDefaultDeclaration\", {\n  visitor: [\"declaration\"],\n  aliases: [\n    \"Statement\",\n    \"Declaration\",\n    \"ImportOrExportDeclaration\",\n    \"ExportDeclaration\",\n  ],\n  fields: {\n    declaration: validateType(\n      \"TSDeclareFunction\",\n      \"FunctionDeclaration\",\n      \"ClassDeclaration\",\n      \"Expression\",\n    ),\n    exportKind: validateOptional(assertOneOf(\"value\")),\n  },\n});\n\ndefineType(\"ExportNamedDeclaration\", {\n  builder: [\"declaration\", \"specifiers\", \"source\"],\n  visitor: process.env.BABEL_8_BREAKING\n    ? [\"declaration\", \"specifiers\", \"source\", \"attributes\"]\n    : [\"declaration\", \"specifiers\", \"source\", \"attributes\", \"assertions\"],\n  aliases: [\n    \"Statement\",\n    \"Declaration\",\n    \"ImportOrExportDeclaration\",\n    \"ExportDeclaration\",\n  ],\n  fields: {\n    declaration: {\n      optional: true,\n      validate:\n        process.env.BABEL_8_BREAKING || process.env.BABEL_TYPES_8_BREAKING\n          ? chain(\n              assertNodeType(\"Declaration\"),\n              Object.assign(\n                function (node: t.ExportNamedDeclaration, key, val) {\n                  // This validator isn't put at the top level because we can run it\n                  // even if this node doesn't have a parent.\n\n                  if (val && node.specifiers.length) {\n                    throw new TypeError(\n                      \"Only declaration or specifiers is allowed on ExportNamedDeclaration\",\n                    );\n                  }\n\n                  // This validator isn't put at the top level because we can run it\n                  // even if this node doesn't have a parent.\n\n                  if (val && node.source) {\n                    throw new TypeError(\n                      \"Cannot export a declaration from a source\",\n                    );\n                  }\n                } satisfies ValidatorImpl,\n                { oneOfNodeTypes: [\"Declaration\"] as const },\n              ) satisfies ValidatorOneOfNodeTypes,\n            )\n          : assertNodeType(\"Declaration\"),\n    },\n    ...importAttributes,\n    specifiers: {\n      default: [],\n      validate: arrayOf(\n        (function () {\n          const sourced = assertNodeType(\n            \"ExportSpecifier\",\n            \"ExportDefaultSpecifier\",\n            \"ExportNamespaceSpecifier\",\n          );\n          const sourceless = assertNodeType(\"ExportSpecifier\");\n\n          if (\n            !process.env.BABEL_8_BREAKING &&\n            !process.env.BABEL_TYPES_8_BREAKING\n          )\n            return sourced;\n\n          return Object.assign(\n            function (node: t.ExportNamedDeclaration, key, val) {\n              const validator = node.source ? sourced : sourceless;\n              validator(node, key, val);\n            } satisfies ValidatorImpl,\n            {\n              oneOfNodeTypes: [\n                \"ExportSpecifier\",\n                \"ExportDefaultSpecifier\",\n                \"ExportNamespaceSpecifier\",\n              ] as const,\n            },\n          ) satisfies ValidatorOneOfNodeTypes;\n        })(),\n      ),\n    },\n    source: {\n      validate: assertNodeType(\"StringLiteral\"),\n      optional: true,\n    },\n    exportKind: validateOptional(assertOneOf(\"type\", \"value\")),\n  },\n});\n\ndefineType(\"ExportSpecifier\", {\n  visitor: [\"local\", \"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n    exported: {\n      validate: assertNodeType(\"Identifier\", \"StringLiteral\"),\n    },\n    exportKind: {\n      // And TypeScript's \"export { type foo } from\"\n      validate: assertOneOf(\"type\", \"value\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ForOfStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  builder: [\"left\", \"right\", \"body\", \"await\"],\n  aliases: [\n    \"Scopable\",\n    \"Statement\",\n    \"For\",\n    \"BlockParent\",\n    \"Loop\",\n    \"ForXStatement\",\n  ],\n  fields: {\n    left: {\n      validate: (function () {\n        if (\n          !process.env.BABEL_8_BREAKING &&\n          !process.env.BABEL_TYPES_8_BREAKING\n        ) {\n          return assertNodeType(\"VariableDeclaration\", \"LVal\");\n        }\n\n        const declaration = assertNodeType(\"VariableDeclaration\");\n        const lval = assertNodeType(\n          \"Identifier\",\n          \"MemberExpression\",\n          \"ArrayPattern\",\n          \"ObjectPattern\",\n          \"TSAsExpression\",\n          \"TSSatisfiesExpression\",\n          \"TSTypeAssertion\",\n          \"TSNonNullExpression\",\n        );\n\n        return Object.assign(\n          function (node, key, val) {\n            if (is(\"VariableDeclaration\", val)) {\n              declaration(node, key, val);\n            } else {\n              lval(node, key, val);\n            }\n          } satisfies ValidatorImpl,\n          {\n            oneOfNodeTypes: [\n              \"VariableDeclaration\",\n              \"Identifier\",\n              \"MemberExpression\",\n              \"ArrayPattern\",\n              \"ObjectPattern\",\n              \"TSAsExpression\",\n              \"TSSatisfiesExpression\",\n              \"TSTypeAssertion\",\n              \"TSNonNullExpression\",\n            ] as const,\n          },\n        ) satisfies ValidatorOneOfNodeTypes;\n      })(),\n    },\n    right: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n    await: {\n      default: false,\n    },\n  },\n});\n\ndefineType(\"ImportDeclaration\", {\n  builder: [\"specifiers\", \"source\"],\n  visitor: process.env.BABEL_8_BREAKING\n    ? [\"specifiers\", \"source\", \"attributes\"]\n    : [\"specifiers\", \"source\", \"attributes\", \"assertions\"],\n  aliases: [\"Statement\", \"Declaration\", \"ImportOrExportDeclaration\"],\n  fields: {\n    ...importAttributes,\n    module: {\n      optional: true,\n      validate: assertValueType(\"boolean\"),\n    },\n    phase: {\n      default: null,\n      validate: assertOneOf(\"source\", \"defer\"),\n    },\n    specifiers: validateArrayOfType(\n      \"ImportSpecifier\",\n      \"ImportDefaultSpecifier\",\n      \"ImportNamespaceSpecifier\",\n    ),\n    source: {\n      validate: assertNodeType(\"StringLiteral\"),\n    },\n    importKind: {\n      // Handle TypeScript/Flowtype's extension \"import type foo from\"\n      // TypeScript doesn't support typeof\n      validate: assertOneOf(\"type\", \"typeof\", \"value\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ImportDefaultSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n  },\n});\n\ndefineType(\"ImportNamespaceSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n  },\n});\n\ndefineType(\"ImportSpecifier\", {\n  visitor: [\"imported\", \"local\"],\n  builder: [\"local\", \"imported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n    imported: {\n      validate: assertNodeType(\"Identifier\", \"StringLiteral\"),\n    },\n    importKind: {\n      // Handle Flowtype's extension \"import {typeof foo} from\"\n      // And TypeScript's \"import { type foo } from\"\n      validate: assertOneOf(\"type\", \"typeof\", \"value\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ImportExpression\", {\n  visitor: [\"source\", \"options\"],\n  aliases: [\"Expression\"],\n  fields: {\n    phase: {\n      default: null,\n      validate: assertOneOf(\"source\", \"defer\"),\n    },\n    source: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    options: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"MetaProperty\", {\n  visitor: [\"meta\", \"property\"],\n  aliases: [\"Expression\"],\n  fields: {\n    meta: {\n      validate:\n        process.env.BABEL_8_BREAKING || process.env.BABEL_TYPES_8_BREAKING\n          ? chain(\n              assertNodeType(\"Identifier\"),\n              Object.assign(\n                function (node: t.MetaProperty, key, val) {\n                  let property;\n                  switch (val.name) {\n                    case \"function\":\n                      property = \"sent\";\n                      break;\n                    case \"new\":\n                      property = \"target\";\n                      break;\n                    case \"import\":\n                      property = \"meta\";\n                      break;\n                  }\n                  if (!is(\"Identifier\", node.property, { name: property })) {\n                    throw new TypeError(\"Unrecognised MetaProperty\");\n                  }\n                } satisfies ValidatorImpl,\n                { oneOfNodeTypes: [\"Identifier\"] as const },\n              ) satisfies ValidatorOneOfNodeTypes,\n            )\n          : assertNodeType(\"Identifier\"),\n    },\n    property: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n  },\n});\n\nexport const classMethodOrPropertyCommon = () => ({\n  abstract: {\n    validate: assertValueType(\"boolean\"),\n    optional: true,\n  },\n  accessibility: {\n    validate: assertOneOf(\"public\", \"private\", \"protected\"),\n    optional: true,\n  },\n  static: {\n    default: false,\n  },\n  override: {\n    default: false,\n  },\n  computed: {\n    default: false,\n  },\n  optional: {\n    validate: assertValueType(\"boolean\"),\n    optional: true,\n  },\n  key: {\n    validate: chain(\n      (function () {\n        const normal = assertNodeType(\n          \"Identifier\",\n          \"StringLiteral\",\n          \"NumericLiteral\",\n          \"BigIntLiteral\",\n        );\n        const computed = assertNodeType(\"Expression\");\n\n        return function (\n          node: Extract<t.Node, { computed: boolean }>,\n          key,\n          val,\n        ) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        } satisfies ValidatorImpl;\n      })(),\n      assertNodeType(\n        \"Identifier\",\n        \"StringLiteral\",\n        \"NumericLiteral\",\n        \"BigIntLiteral\",\n        \"Expression\",\n      ),\n    ),\n  },\n});\n\nexport const classMethodOrDeclareMethodCommon = () => ({\n  ...functionCommon(),\n  ...classMethodOrPropertyCommon(),\n  params: validateArrayOfType(\"FunctionParameter\", \"TSParameterProperty\"),\n  kind: {\n    validate: assertOneOf(\"get\", \"set\", \"method\", \"constructor\"),\n    default: \"method\",\n  },\n  access: {\n    validate: chain(\n      assertValueType(\"string\"),\n      assertOneOf(\"public\", \"private\", \"protected\"),\n    ),\n    optional: true,\n  },\n  decorators: {\n    validate: arrayOfType(\"Decorator\"),\n    optional: true,\n  },\n});\n\ndefineType(\"ClassMethod\", {\n  aliases: [\"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\"],\n  builder: [\n    \"kind\",\n    \"key\",\n    \"params\",\n    \"body\",\n    \"computed\",\n    \"static\",\n    \"generator\",\n    \"async\",\n  ],\n  visitor: [\n    \"decorators\",\n    \"key\",\n    \"typeParameters\",\n    \"params\",\n    \"returnType\",\n    \"body\",\n  ],\n  ...classMethodOrPropertyUnionShapeCommon(),\n  fields: {\n    ...classMethodOrDeclareMethodCommon(),\n    ...functionTypeAnnotationCommon(),\n    body: {\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n  },\n});\n\ndefineType(\"ObjectPattern\", {\n  visitor: [\n    \"decorators\" /* for legacy param decorators */,\n    \"properties\",\n    \"typeAnnotation\",\n  ],\n  builder: [\"properties\"],\n  aliases: [\"FunctionParameter\", \"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: {\n    ...patternLikeCommon(),\n    properties: validateArrayOfType(\"RestElement\", \"ObjectProperty\"),\n  },\n});\n\ndefineType(\"SpreadElement\", {\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\"],\n  deprecatedAlias: \"SpreadProperty\",\n  fields: {\n    argument: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\ndefineType(\n  \"Super\",\n  process.env.BABEL_8_BREAKING\n    ? undefined\n    : {\n        aliases: [\"Expression\"],\n      },\n);\n\ndefineType(\"TaggedTemplateExpression\", {\n  visitor: process.env.BABEL_8_BREAKING\n    ? [\"tag\", \"typeArguments\", \"quasi\"]\n    : [\"tag\", \"typeParameters\", \"quasi\"],\n  builder: [\"tag\", \"quasi\"],\n  aliases: [\"Expression\"],\n  fields: {\n    tag: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    quasi: {\n      validate: assertNodeType(\"TemplateLiteral\"),\n    },\n    [process.env.BABEL_8_BREAKING ? \"typeArguments\" : \"typeParameters\"]: {\n      validate: assertNodeType(\n        \"TypeParameterInstantiation\",\n        \"TSTypeParameterInstantiation\",\n      ),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"TemplateElement\", {\n  builder: [\"value\", \"tail\"],\n  fields: {\n    value: {\n      validate: chain(\n        assertShape({\n          raw: {\n            validate: assertValueType(\"string\"),\n          },\n          cooked: {\n            validate: assertValueType(\"string\"),\n            optional: true,\n          },\n        }),\n        function templateElementCookedValidator(node: t.TemplateElement) {\n          const raw = node.value.raw;\n\n          let unterminatedCalled = false;\n\n          const error = () => {\n            // unreachable\n            throw new Error(\"Internal @babel/types error.\");\n          };\n          const { str, firstInvalidLoc } = readStringContents(\n            \"template\",\n            raw,\n            0,\n            0,\n            0,\n            {\n              unterminated() {\n                unterminatedCalled = true;\n              },\n              strictNumericEscape: error,\n              invalidEscapeSequence: error,\n              numericSeparatorInEscapeSequence: error,\n              unexpectedNumericSeparator: error,\n              invalidDigit: error,\n              invalidCodePoint: error,\n            },\n          );\n          if (!unterminatedCalled) throw new Error(\"Invalid raw\");\n\n          node.value.cooked = firstInvalidLoc ? null : str;\n        },\n      ),\n    },\n    tail: {\n      default: false,\n    },\n  },\n});\n\ndefineType(\"TemplateLiteral\", {\n  visitor: [\"quasis\", \"expressions\"],\n  aliases: [\"Expression\", \"Literal\"],\n  fields: {\n    quasis: validateArrayOfType(\"TemplateElement\"),\n    expressions: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(\n          assertNodeType(\n            \"Expression\",\n            // For TypeScript template literal types\n            \"TSType\",\n          ),\n        ),\n        function (node: t.TemplateLiteral, key, val) {\n          if (node.quasis.length !== val.length + 1) {\n            throw new TypeError(\n              `Number of ${\n                node.type\n              } quasis should be exactly one more than the number of expressions.\\nExpected ${\n                val.length + 1\n              } quasis but got ${node.quasis.length}`,\n            );\n          }\n        } satisfies ValidatorImpl,\n      ),\n    },\n  },\n});\n\ndefineType(\"YieldExpression\", {\n  builder: [\"argument\", \"delegate\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    delegate: {\n      validate:\n        process.env.BABEL_8_BREAKING || process.env.BABEL_TYPES_8_BREAKING\n          ? chain(\n              assertValueType(\"boolean\"),\n              Object.assign(\n                function (node: t.YieldExpression, key, val) {\n                  if (val && !node.argument) {\n                    throw new TypeError(\n                      \"Property delegate of YieldExpression cannot be true if there is no argument\",\n                    );\n                  }\n                } satisfies ValidatorImpl,\n                { type: \"boolean\" as const },\n              ) satisfies ValidatorType,\n            )\n          : assertValueType(\"boolean\"),\n      default: false,\n    },\n    argument: {\n      optional: true,\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\n// --- ES2017 ---\ndefineType(\"AwaitExpression\", {\n  builder: [\"argument\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    argument: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\n// --- ES2019 ---\ndefineType(\"Import\", {\n  aliases: [\"Expression\"],\n});\n\n// --- ES2020 ---\ndefineType(\"BigIntLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: process.env.BABEL_8_BREAKING\n        ? assertValueType(\"bigint\")\n        : assertValueType(\"string\"),\n    },\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"],\n});\n\ndefineType(\"ExportNamespaceSpecifier\", {\n  visitor: [\"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    exported: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n  },\n});\n\ndefineType(\"OptionalMemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\", \"optional\"],\n  visitor: [\"object\", \"property\"],\n  // todo: Add OptionalMemberExpression to LVal when optional-chaining-assign reaches stage 4\n  aliases: [\"Expression\"],\n  fields: {\n    object: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    property: {\n      validate: (function () {\n        const normal = assertNodeType(\"Identifier\");\n        const computed = assertNodeType(\"Expression\");\n\n        const validator: ValidatorOneOfNodeTypes = Object.assign(\n          function (node: t.OptionalMemberExpression, key, val) {\n            const validator = node.computed ? computed : normal;\n            validator(node, key, val);\n          } satisfies ValidatorImpl,\n          // todo(ts): can be discriminated union by `computed` property\n          { oneOfNodeTypes: [\"Expression\", \"Identifier\"] as const },\n        );\n        return validator;\n      })(),\n    },\n    computed: {\n      default: false,\n    },\n    optional: {\n      validate:\n        !process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n          ? assertValueType(\"boolean\")\n          : chain(assertValueType(\"boolean\"), assertOptionalChainStart()),\n    },\n  },\n});\n\ndefineType(\"OptionalCallExpression\", {\n  visitor: process.env.BABEL_8_BREAKING\n    ? [\"callee\", \"typeArguments\", \"arguments\"]\n    : [\"callee\", \"typeParameters\", \"typeArguments\", \"arguments\"],\n  builder: [\"callee\", \"arguments\", \"optional\"],\n  aliases: [\"Expression\"],\n  fields: {\n    callee: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    arguments: validateArrayOfType(\n      \"Expression\",\n      \"SpreadElement\",\n      \"ArgumentPlaceholder\",\n    ),\n    optional: {\n      validate:\n        !process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n          ? assertValueType(\"boolean\")\n          : chain(assertValueType(\"boolean\"), assertOptionalChainStart()),\n    },\n    typeArguments: {\n      validate: process.env.BABEL_8_BREAKING\n        ? assertNodeType(\n            \"TypeParameterInstantiation\",\n            \"TSTypeParameterInstantiation\",\n          )\n        : assertNodeType(\"TypeParameterInstantiation\"),\n      optional: true,\n    },\n    ...(process.env.BABEL_8_BREAKING\n      ? {}\n      : {\n          typeParameters: {\n            validate: assertNodeType(\"TSTypeParameterInstantiation\"),\n            optional: true,\n          },\n        }),\n  },\n});\n\n// --- ES2022 ---\ndefineType(\"ClassProperty\", {\n  visitor: [\"decorators\", \"variance\", \"key\", \"typeAnnotation\", \"value\"],\n  builder: [\n    \"key\",\n    \"value\",\n    \"typeAnnotation\",\n    \"decorators\",\n    \"computed\",\n    \"static\",\n  ],\n  aliases: [\"Property\"],\n  ...classMethodOrPropertyUnionShapeCommon(),\n  fields: {\n    ...classMethodOrPropertyCommon(),\n    value: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n    definite: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    typeAnnotation: {\n      validate: process.env.BABEL_8_BREAKING\n        ? assertNodeType(\"TypeAnnotation\", \"TSTypeAnnotation\")\n        : assertNodeType(\n            \"TypeAnnotation\",\n            \"TSTypeAnnotation\",\n            // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n            \"Noop\",\n          ),\n      optional: true,\n    },\n    decorators: {\n      validate: arrayOfType(\"Decorator\"),\n      optional: true,\n    },\n    readonly: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    declare: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    variance: {\n      validate: assertNodeType(\"Variance\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ClassAccessorProperty\", {\n  visitor: [\"decorators\", \"key\", \"typeAnnotation\", \"value\"],\n  builder: [\n    \"key\",\n    \"value\",\n    \"typeAnnotation\",\n    \"decorators\",\n    \"computed\",\n    \"static\",\n  ],\n  aliases: [\"Property\", \"Accessor\"],\n  ...classMethodOrPropertyUnionShapeCommon(true),\n  fields: {\n    ...classMethodOrPropertyCommon(),\n    key: {\n      validate: chain(\n        (function () {\n          const normal = assertNodeType(\n            \"Identifier\",\n            \"StringLiteral\",\n            \"NumericLiteral\",\n            \"BigIntLiteral\",\n            \"PrivateName\",\n          );\n          const computed = assertNodeType(\"Expression\");\n\n          return function (\n            node: t.ClassAccessorProperty,\n            key: string,\n            val: any,\n          ) {\n            const validator = node.computed ? computed : normal;\n            validator(node, key, val);\n          } satisfies ValidatorImpl;\n        })(),\n        assertNodeType(\n          \"Identifier\",\n          \"StringLiteral\",\n          \"NumericLiteral\",\n          \"BigIntLiteral\",\n          \"Expression\",\n          \"PrivateName\",\n        ),\n      ),\n    },\n    value: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n    definite: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    typeAnnotation: {\n      validate: process.env.BABEL_8_BREAKING\n        ? assertNodeType(\"TypeAnnotation\", \"TSTypeAnnotation\")\n        : assertNodeType(\n            \"TypeAnnotation\",\n            \"TSTypeAnnotation\",\n            // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n            \"Noop\",\n          ),\n      optional: true,\n    },\n    decorators: {\n      validate: arrayOfType(\"Decorator\"),\n      optional: true,\n    },\n    readonly: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    declare: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    variance: {\n      validate: assertNodeType(\"Variance\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ClassPrivateProperty\", {\n  visitor: [\"decorators\", \"variance\", \"key\", \"typeAnnotation\", \"value\"],\n  builder: [\"key\", \"value\", \"decorators\", \"static\"],\n  aliases: [\"Property\", \"Private\"],\n  fields: {\n    key: {\n      validate: assertNodeType(\"PrivateName\"),\n    },\n    value: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n    typeAnnotation: {\n      validate: process.env.BABEL_8_BREAKING\n        ? assertNodeType(\"TypeAnnotation\", \"TSTypeAnnotation\")\n        : assertNodeType(\n            \"TypeAnnotation\",\n            \"TSTypeAnnotation\",\n            // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n            \"Noop\",\n          ),\n      optional: true,\n    },\n    decorators: {\n      validate: arrayOfType(\"Decorator\"),\n      optional: true,\n    },\n    static: {\n      validate: assertValueType(\"boolean\"),\n      default: false,\n    },\n    readonly: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    optional: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    definite: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    variance: {\n      validate: assertNodeType(\"Variance\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ClassPrivateMethod\", {\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"static\"],\n  visitor: [\n    \"decorators\",\n    \"key\",\n    \"typeParameters\",\n    \"params\",\n    \"returnType\",\n    \"body\",\n  ],\n  aliases: [\n    \"Function\",\n    \"Scopable\",\n    \"BlockParent\",\n    \"FunctionParent\",\n    \"Method\",\n    \"Private\",\n  ],\n  // `computed` is not included in the `builder`\n  // ...classMethodOrPropertyUnionShapeCommon(),\n  fields: {\n    ...classMethodOrDeclareMethodCommon(),\n    ...functionTypeAnnotationCommon(),\n    kind: {\n      validate: assertOneOf(\"get\", \"set\", \"method\"),\n      default: \"method\",\n    },\n    key: {\n      validate: assertNodeType(\"PrivateName\"),\n    },\n    body: {\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n  },\n});\n\ndefineType(\"PrivateName\", {\n  visitor: [\"id\"],\n  aliases: [\"Private\"],\n  fields: {\n    id: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n  },\n});\n\ndefineType(\"StaticBlock\", {\n  visitor: [\"body\"],\n  fields: {\n    body: validateArrayOfType(\"Statement\"),\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"FunctionParent\"],\n});\n\n// --- ES2025 ---\ndefineType(\"ImportAttribute\", {\n  visitor: [\"key\", \"value\"],\n  fields: {\n    key: {\n      validate: assertNodeType(\"Identifier\", \"StringLiteral\"),\n    },\n    value: {\n      validate: assertNodeType(\"StringLiteral\"),\n    },\n  },\n});\n"],"mappings":"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","ignoreList":[]}